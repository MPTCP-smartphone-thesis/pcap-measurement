#! /usr/bin/python
# -*- coding: utf-8 -*-
#
#  Copyright 2015 Matthieu Baerts & Quentin De Coninck
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#  To install on this machine: matplotlib, numpy

from __future__ import print_function

##################################################
##                   IMPORTS                    ##
##################################################

import argparse
import common as co
from math import ceil
import matplotlib
# Do not use any X11 backend
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import mptcp
import numpy as np
import os
import os.path
import pickle
import sys
import tcp
import time

##################################################
##                  ARGUMENTS                   ##
##################################################

parser = argparse.ArgumentParser(
    description="Summarize stat files generated by analyze")
parser.add_argument("-s",
                    "--stat", help="directory where the stat files are stored", default=co.DEF_STAT_DIR+'_'+co.DEF_IFACE)
parser.add_argument('-S',
                    "--sums", help="directory where the summary graphs will be stored", default=co.DEF_SUMS_DIR+'_'+co.DEF_IFACE)
parser.add_argument("-d",
                    "--dirs", help="list of directories to aggregate", nargs="+")
parser.add_argument("-r",
                    "--remove", help="if set, remove outliers from dataset", action="store_true")

args = parser.parse_args()

stat_dir_exp = os.path.abspath(os.path.expanduser(args.stat))
sums_dir_exp = os.path.abspath(os.path.expanduser(args.sums))

co.check_directory_exists(sums_dir_exp)

##################################################
##                 GET THE DATA                 ##
##################################################


def check_in_list(dirpath, dirs):
    """ Check if dirpath is one of the dir in dirs, True if dirs is empty """
    if not dirs:
        return True
    return os.path.basename(dirpath) in dirs


def fetch_data(dir_exp):
    co.check_directory_exists(dir_exp)
    dico = {}
    for dirpath, dirnames, filenames in os.walk(dir_exp):
        if check_in_list(dirpath, args.dirs):
            for fname in filenames:
                try:
                    stat_file = open(os.path.join(dirpath, fname), 'r')
                    dico[fname] = pickle.load(stat_file)
                    stat_file.close()
                except IOError as e:
                    print(str(e) + ': skip stat file ' + fname, file=sys.stderr)
    return dico

connections = fetch_data(stat_dir_exp)


def ensures_smartphone_to_proxy():
    for fname in connections.keys():
        for conn_id in connections[fname].keys():
            if isinstance(connections[fname][conn_id], mptcp.MPTCPConnection):
                inside = True
                for flow_id, flow in connections[fname][conn_id].flows.iteritems():
                    if not flow.attr[co.DADDR].startswith('172.17.') and not flow.attr[co.DADDR] == co.IP_PROXY:
                        connections[fname].pop(conn_id, None)
                        inside = False
                        break
                if inside:
                    for direction in co.DIRECTIONS:
                        # This is a fix for wrapping seq num
                        if connections[fname][conn_id].attr[direction][co.BYTES_MPTCPTRACE] < -1:
                            connections[fname][conn_id].attr[direction][co.BYTES_MPTCPTRACE] = 2**32 + connections[fname][conn_id].attr[direction][co.BYTES_MPTCPTRACE]

ensures_smartphone_to_proxy()


def get_multiflow_connections(connections):
    multiflow_connections = {}
    singleflow_connections = {}
    for fname, conns_fname in connections.iteritems():
        for conn_id, conn in conns_fname.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                if len(conn.flows) > 1:
                    if fname not in multiflow_connections:
                        multiflow_connections[fname] = {}
                    multiflow_connections[fname][conn_id] = conn
                else:
                    if fname not in singleflow_connections:
                        singleflow_connections[fname] = {}
                    singleflow_connections[fname][conn_id] = conn

    return multiflow_connections, singleflow_connections

multiflow_connections, singleflow_connections = get_multiflow_connections(connections)

def filter_connections(connections, min_bytes=None, max_bytes=None):
    filtered = {}

    for fname, data in connections.iteritems():
        filtered[fname] = {}
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                mptcp_bytes = conn.attr[co.S2D].get(co.BYTES_MPTCPTRACE, 0) + conn.attr[co.D2S].get(co.BYTES_MPTCPTRACE, 0)
                if (min_bytes and mptcp_bytes >= min_bytes) or (max_bytes and mptcp_bytes <= max_bytes):
                    filtered[fname][conn_id] = conn

    return filtered

# connections = filter_connections(connections)

##################################################
##               PLOTTING RESULTS               ##
##################################################


def fog_plot_with_bytes_wifi_cell_per_condition(log_file=sys.stdout):
    data = {co.S2D: {'all': {'Connections': []}}, co.D2S: {'all': {'Connections': []}}}
    color = {'Connections': 'orange'}
    base_graph_name = "fog_bytes"

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            if co.BYTES in conn.attr[co.S2D]:
                data[co.S2D]['all']['Connections'].append([conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0), conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)])
            if co.BYTES in conn.attr[co.D2S]:
                data[co.D2S]['all']['Connections'].append([conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0), conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)])

    co.scatter_plot_with_direction(data, "Bytes on Wi-Fi", "Bytes on cellular", color, sums_dir_exp, base_graph_name)


def fog_plot_with_packs_wifi_cell_per_condition(log_file=sys.stdout):
    data = {co.S2D: {'all': {'Connections': []}}, co.D2S: {'all': {'Connections': []}}}
    color = {'Connections': 'orange'}
    base_graph_name = "fog_packs"

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # conn is then a MPTCPConnection, be still better to be sure of
            if isinstance(conn, mptcp.MPTCPConnection):
                packs = {co.S2D: {co.CELL: 0, co.WIFI: 0, '?': 0}, co.D2S: {co.CELL: 0, co.WIFI: 0, '?': 0}}
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D not in flow.attr:
                        continue
                    if co.PACKS not in flow.attr[co.S2D] or co.PACKS not in flow.attr[co.D2S]:
                        break
                    interface = flow.attr[co.IF]
                    packs[co.S2D][interface] += flow.attr[co.S2D][co.PACKS]
                    packs[co.D2S][interface] += flow.attr[co.D2S][co.PACKS]

                if packs[co.S2D][co.CELL] == 0 and packs[co.S2D][co.WIFI] == 0 and packs[co.D2S][co.CELL] == 0 and packs[co.D2S][co.WIFI] == 0:
                    continue

                data[co.S2D]['all']['Connections'].append([packs[co.S2D][co.WIFI], packs[co.S2D][co.CELL]])
                data[co.D2S]['all']['Connections'].append([packs[co.D2S][co.WIFI], packs[co.D2S][co.CELL]])

    co.scatter_plot_with_direction(data, "Packets on wifi", "Packets on cellular", color, sums_dir_exp, base_graph_name)


def fog_duration_bytes(log_file=sys.stdout):
    data = {'all': {'Connections': []}}
    color = {'Connections': 'orange'}
    base_graph_name = "fog_duration_bytes"

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                duration = conn.attr[co.DURATION]
            nb_bytes = 0
            if co.BYTES in conn.attr[co.S2D]:
                nb_bytes = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0) + conn.attr[co.S2D][co.BYTES].get('?', 0)
            if co.BYTES in conn.attr[co.D2S]:
                nb_bytes += conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0) + conn.attr[co.D2S][co.BYTES].get('?', 0)
            data['all']['Connections'].append([duration, nb_bytes])

    co.scatter_plot(data, "Duration [s]", "Bytes on connection", color, sums_dir_exp, base_graph_name, plot_identity=False)


def cdf_duration(log_file=sys.stdout):
    data_duration = {'all': {co.DURATION: []}}
    color = ['red']
    base_graph_name_duration = "summary_cdf_duration"
    base_graph_path_duration = os.path.join(sums_dir_exp, base_graph_name_duration)
    base_graph_name_duration_hist = "summary_hist_duration"
    base_graph_path_duration_hist = os.path.join(sums_dir_exp, base_graph_name_duration_hist)

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                duration = conn.attr[co.DURATION]

            data_duration['all'][co.DURATION].append(duration)

    co.plot_cdfs_natural(data_duration, color, 'Seconds [s]', base_graph_path_duration)
    co.plot_cdfs_natural(data_duration, color, 'Seconds [s]', base_graph_path_duration + '_log', xlog=True)
    # weights = []
    # for dataset_results in data_duration['all'][co.DURATION]:
    #     weights.append(np.ones_like(dataset_results) / len(data_duration['all'][co.DURATION]))
    plt.figure()
    plt.hist(data_duration['all'][co.DURATION], bins=np.logspace(-3, 5, 81), log=True)
    plt.xlabel("Duration of connections [s]", fontsize=18)
    plt.ylabel("Connections", fontsize=18)
    plt.gca().set_xscale("log")
    plt.savefig(base_graph_path_duration_hist + "_log.pdf")
    plt.close()
    plt.figure()
    plt.hist(data_duration['all'][co.DURATION], bins=np.logspace(-3, 5, 81))
    plt.xlabel("Duration of connections [s]", fontsize=18)
    plt.ylabel("Connections", fontsize=18)
    plt.gca().set_xscale("log")
    plt.savefig(base_graph_path_duration_hist + ".pdf")
    plt.close()
    print("50th percentile", np.percentile(data_duration['all'][co.DURATION], 50), file=log_file)
    print("60th percentile", np.percentile(data_duration['all'][co.DURATION], 60), file=log_file)
    print("70th percentile", np.percentile(data_duration['all'][co.DURATION], 70), file=log_file)


def cdfs_bytes(log_file=sys.stdout):
    data_bytes = {'all': {co.BYTES: []}}
    data_bytes_with_dir = {co.S2D: {'all': {co.BYTES: []}}, co.D2S: {'all': {co.BYTES: []}}}
    color = ['red']
    base_graph_name_bytes = "summary_cdf_bytes"
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # An alternative version could be written with the bytes returned by mptcptrace, it would then be
            # nb_bytes_s2d = conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
            # nb_bytes_d2s = conn.attr[co.D2S][co.BYTES_MPTCPTRACE]
            if co.BYTES in conn.attr[co.S2D]:
                nb_bytes_s2d = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)
            if co.BYTES in conn.attr[co.D2S]:
                nb_bytes_d2s = conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)

            data_bytes['all'][co.BYTES].append(nb_bytes_s2d + nb_bytes_d2s)
            data_bytes_with_dir[co.S2D]['all'][co.BYTES].append(nb_bytes_s2d)
            data_bytes_with_dir[co.D2S]['all'][co.BYTES].append(nb_bytes_d2s)

    co.plot_cdfs_natural(data_bytes, color, 'Bytes', base_graph_path_bytes)
    co.plot_cdfs_with_direction(data_bytes_with_dir, color, 'Bytes', base_graph_path_bytes, natural=True)


def cdf_number_subflows(log_file=sys.stdout):
    subflows = {'all': {'Subflows': []}}
    nb_subflows = {}
    color = ['red']
    base_graph_name_subflows = "cdf_number_subflows"
    base_graph_path_subflows = os.path.join(sums_dir_exp, base_graph_name_subflows)

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # Make sure we have MPTCPConnections, but it should always be the case
            if isinstance(conn, mptcp.MPTCPConnection):
                subflows['all']['Subflows'].append(len(conn.flows))
                if len(conn.flows) not in nb_subflows:
                    nb_subflows[len(conn.flows)] = 1
                else:
                    nb_subflows[len(conn.flows)] += 1
            elif isinstance(conn, tcp.TCPConnection):
                print("WARNING: there is a TCPConnection!")

    co.plot_cdfs_natural(subflows, color, '# of subflows', base_graph_path_subflows)
    print(nb_subflows, file=log_file)


def count_unused_subflows(log_file=sys.stdout):
    count = 0
    count_total = 0
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # Still make sure it's MPTCPConnections
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    unused_subflow = True
                    for direction in co.DIRECTIONS:
                        # Count data bytes
                        if flow.attr[direction].get(co.BYTES_DATA, 0) > 0:
                            unused_subflow = False

                    count_total += 1
                    if unused_subflow:
                        count += 1

    count_multiflow = 0
    count_unused_multiflow = 0
    count_unused_additional = 0
    count_unused_best_avg_rtt = 0
    count_multiflow_additional = 0
    bytes_when_unused = []
    duration_when_unused = []
    for fname, conns, in multiflow_connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # Still make sure it's MPTCPConnections
            if isinstance(conn, mptcp.MPTCPConnection):
                start_time = float('inf')
                for flow_id, flow in conn.flows.iteritems():
                    start_time = min(start_time, flow.attr.get(co.START, float('inf')))
                if start_time == float('inf'):
                    continue
                for flow_id, flow in conn.flows.iteritems():
                    unused_subflow = True
                    for direction in co.DIRECTIONS:
                        # Count data bytes
                        if flow.attr[direction].get(co.BYTES_DATA, 0) > 0:
                            unused_subflow = False
                    if unused_subflow:
                        count_unused_multiflow += 1
                    count_multiflow += 1
                    if not start_time == flow.attr.get(co.START, float('inf')):
                        count_multiflow_additional += 1
                        if unused_subflow:
                            count_unused_additional += 1
                            min_rtt_avg = float('inf')
                            for fid, fl in conn.flows.iteritems():
                                if co.RTT_AVG in flow.attr[co.D2S]:
                                    min_rtt_avg = min(min_rtt_avg, fl.attr[co.D2S].get(co.RTT_AVG, float('inf')))
                            if co.RTT_AVG in flow.attr[co.D2S] and flow.attr[co.D2S][co.RTT_AVG] == min_rtt_avg:
                                count_unused_best_avg_rtt += 1
                                bytes_when_unused.append(conn.attr[co.D2S].get(co.BYTES_MPTCPTRACE, 0))
                                if co.DURATION in conn.attr:
                                    duration_when_unused.append(conn.attr[co.DURATION])

    print("Number of unused subflows:", count, file=log_file)
    print("Number of total subflows:", count_total, file=log_file)
    print("Number of subflows in multiflow connections", count_multiflow, file=log_file)
    print("Number of additional subflows in multiflow connections", count_multiflow_additional, file=log_file)
    print("Number of unused subflows on multiflow connections", count_unused_multiflow, file=log_file)
    print("Number of unused additional subflows on multiflow connections", count_unused_additional, file=log_file)
    print("Number of unused additional subflows on multiflow connections with best RTT", count_unused_best_avg_rtt, file=log_file)
    print(np.min(bytes_when_unused), np.percentile(bytes_when_unused, 50), np.mean(bytes_when_unused), np.percentile(bytes_when_unused, 75), np.percentile(bytes_when_unused, 90), np.percentile(bytes_when_unused, 95), np.percentile(bytes_when_unused, 96), np.percentile(bytes_when_unused, 97), np.percentile(bytes_when_unused, 98), np.percentile(bytes_when_unused, 99), np.max(bytes_when_unused), file=log_file)
    print(np.min(duration_when_unused), np.percentile(duration_when_unused, 50), np.mean(duration_when_unused), np.percentile(duration_when_unused, 75), np.percentile(duration_when_unused, 90), np.percentile(duration_when_unused, 95), np.percentile(duration_when_unused, 96), np.percentile(duration_when_unused, 97), np.percentile(duration_when_unused, 98), np.percentile(duration_when_unused, 99), np.max(duration_when_unused), file=log_file)


def textual_summary(log_file=sys.stdout):
    data = {'all': {'<1s': 0, ">=1s<10K": 0, ">=1s>=10K": 0, "<9s": 0, ">=9s<10K": 0, ">=9s>=10K": 0, '<10K': 0, '<1K': 0, '1B': 0, '2B': 0, '>=100s': 0, '<10s': 0, '>=1M': 0}}
    count = {'all': {'<1s': 0, ">=1s<10K": 0, ">=1s>=10K": 0, "<9s": 0, ">=9s<10K": 0, ">=9s>=10K": 0, '<10K': 0, '<1K': 0, '1B': 0, '2B': 0, '>=100s': 0, '<10s': 0, '>=1M': 0}}
    tot_count = {'all': 0.0}

    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                duration = conn.attr[co.DURATION]

            nb_bytes_s2d = 0
            nb_bytes_d2s = 0

            # An alternative version could be written with the bytes returned by mptcptrace, it would then be
            nb_bytes_s2d = conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
            nb_bytes_d2s = conn.attr[co.D2S][co.BYTES_MPTCPTRACE]
            # if co.BYTES in conn.attr[co.S2D]:
            #     nb_bytes_s2d = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0) + conn.attr[co.S2D][co.BYTES].get('?', 0)
            # if co.BYTES in conn.attr[co.D2S]:
            #     nb_bytes_d2s = conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0) + conn.attr[co.D2S][co.BYTES].get('?', 0)

            if duration < 1:
                data['all']['<1s'] += nb_bytes_s2d + nb_bytes_d2s
                count['all']['<1s'] += 1
            else:
                if nb_bytes_s2d + nb_bytes_d2s < 10000:
                    data['all'][">=1s<10K"] += nb_bytes_s2d + nb_bytes_d2s
                    count['all'][">=1s<10K"] += 1
                else:
                    data['all'][">=1s>=10K"] += nb_bytes_s2d + nb_bytes_d2s
                    count['all'][">=1s>=10K"] += 1

            if duration >= 100.0:
                count['all']['>=100s'] += 1
                data['all']['>=100s'] += nb_bytes_s2d + nb_bytes_d2s
            elif duration < 10.0:
                count['all']['<10s'] += 1
                data['all']['<10s'] += nb_bytes_s2d + nb_bytes_d2s

            if nb_bytes_s2d + nb_bytes_d2s == 2:
                count['all']['2B'] += 1
                data['all']['2B'] += nb_bytes_s2d + nb_bytes_d2s
            elif nb_bytes_s2d + nb_bytes_d2s == 1:
                count['all']['1B'] += 1
                data['all']['1B'] += nb_bytes_s2d + nb_bytes_d2s
            if nb_bytes_s2d + nb_bytes_d2s < 1000:
                count['all']['<1K'] += 1
                data['all']['<1K'] += nb_bytes_s2d + nb_bytes_d2s
            if nb_bytes_s2d + nb_bytes_d2s < 10000:
                count['all']['<10K'] += 1
                data['all']['<10K'] += nb_bytes_s2d + nb_bytes_d2s
            elif nb_bytes_s2d + nb_bytes_d2s >= 1000000:
                count['all']['>=1M'] += 1
                data['all']['>=1M'] += nb_bytes_s2d + nb_bytes_d2s
            if duration < 9:
                data['all']["<9s"] += nb_bytes_s2d + nb_bytes_d2s
                count['all']["<9s"] += 1
            else:
                if nb_bytes_s2d + nb_bytes_d2s < 10000:
                    data['all'][">=9s<10K"] += nb_bytes_s2d + nb_bytes_d2s
                    count['all'][">=9s<10K"] += 1
                else:
                    data['all'][">=9s>=10K"] += nb_bytes_s2d + nb_bytes_d2s
                    count['all'][">=9s>=10K"] += 1
            tot_count['all'] += 1

    for cond, data_cond in data.iteritems():
        print(cond + " with " + str(tot_count[cond]) + "connections:", file=log_file)
        total = 0.0
        for dur_type, value in data_cond.iteritems():
            total += value
        for dur_type, value in data_cond.iteritems():
            print(dur_type + " (has " + str(count[cond][dur_type]) + " with " + str(count[cond][dur_type] * 100 / (tot_count[cond] + 0.00001)) + "%): " + str(value) + " bytes (" + str(value * 100 / (total+ 0.00001)) + "%)", file=log_file)


def count_ip_type(log_file=sys.stdout):
    results = {co.IPv4: [], co.IPv6: []}
    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    ip_type = flow.attr[co.TYPE]
                    if flow.attr[co.SADDR] not in results[ip_type]:
                        results[ip_type].append(flow.attr[co.SADDR])

    print("IPv4", file=log_file)
    print(results[co.IPv4], file=log_file)
    print("IPv6", file=log_file)
    print(results[co.IPv6], file=log_file)
    print("IPv4", len(results[co.IPv4]), "IPv6", len(results[co.IPv6]), file=log_file)


def count_packet(log_file=sys.stdout):
    count = {co.S2D: 0, co.D2S: 0}

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    for direction in co.DIRECTIONS:
                        count[direction] += flow.attr[direction].get(co.PACKS, 0)

    print("NB PACKETS S2D", count[co.S2D], "NB PACKETS D2S", count[co.D2S], file=log_file)


def count_ports(log_file=sys.stdout):
    count = {co.SPORT: {}, co.DPORT: {}}

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    for port in [co.SPORT, co.DPORT]:
                        if flow.attr[port] in count[port]:
                            count[port][flow.attr[port]] += 1
                        else:
                            count[port][flow.attr[port]] = 1

    print("PORT SOURCE", file=log_file)
    print(count[co.SPORT], file=log_file)
    print("PORT DEST", file=log_file)
    print(count[co.DPORT], file=log_file)


def count_ports_mptcp(log_file=sys.stdout):
    count_mptcp = {}
    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                if conn.flows['0'].attr[co.DPORT] in count_mptcp:
                    count_mptcp[conn.flows['0'].attr[co.DPORT]] += 1
                else:
                    count_mptcp[conn.flows['0'].attr[co.DPORT]] = 1

    print("PORT DEST MPTCP", file=log_file)
    print(count_mptcp, file=log_file)

def count_on_filtered(min_bytes=1000000, log_file=sys.stdout):
    count_bytes = {co.S2D: 0, co.D2S: 0}
    count_packs = {co.S2D: 0, co.D2S: 0}
    count_conn = 0
    ports = {co.SPORT: {}, co.DPORT: {}}

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                mptcp_bytes = conn.attr[co.S2D].get(co.BYTES_MPTCPTRACE, 0) + conn.attr[co.D2S].get(co.BYTES_MPTCPTRACE, 0)
                if mptcp_bytes >= min_bytes:
                    count_conn += 1
                    for direction in co.DIRECTIONS:
                        count_bytes[direction] += conn.attr[direction].get(co.BYTES_MPTCPTRACE, 0)
                    for flow_id, flow in conn.flows.iteritems():
                        for port in [co.SPORT, co.DPORT]:
                            if flow.attr[port] in ports[port]:
                                ports[port][flow.attr[port]] += 1
                            else:
                                ports[port][flow.attr[port]] = 1
                        for direction in co.DIRECTIONS:
                            count_packs[direction] += flow.attr[direction].get(co.PACKS, 0)

    print("NB CONN FILTERED", count_conn, file=log_file)
    print("BYTES S2D FILTERED", count_bytes[co.S2D], "BYTES D2S FILTERED", count_bytes[co.D2S], file=log_file)
    print("PACKS S2D FILTERED", count_packs[co.S2D], "PACKS D2S FILTERED", count_packs[co.D2S], file=log_file)
    print("PORT SOURCE FILTER", file=log_file)
    print(ports[co.SPORT], file=log_file)
    print("PORT DEST FILTER", file=log_file)
    print(ports[co.DPORT], file=log_file)


def box_plot_cellular_percentage(log_file=sys.stdout, limit_duration=0, limit_bytes=0):
    base_graph_name_bytes = "summary_fraction_cellular"
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)

    fog_base_graph_name_bytes = "fog_cellular"
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Connections': 'orange'}
    data_bytes = {'all': {}}
    data_frac = {'all': {}}
    nb_zero = {'all': {}}
    bytes_zero = {'all': {}}
    nb_one = {'all': {}}
    bytes_one = {'all': {}}
    tot_conn = {'all': {}}
    tot_bytes = {'all': {}}

    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in data_bytes:
        data_bytes[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in nb_zero:
        nb_zero[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in bytes_zero:
        bytes_zero[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in nb_one:
        nb_one[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in bytes_one:
        bytes_one[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in tot_conn:
        tot_conn[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in tot_bytes:
        tot_bytes[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        app = "Connections"
        for conn_id, conn in data.iteritems():
            if app not in data_frac['all'][co.S2D]:
                for direction in data_frac['all'].keys():
                    data_frac['all'][direction][app] = []
                    data_bytes['all'][direction][app] = []
                    nb_zero['all'][direction][app] = 0
                    bytes_zero['all'][direction][app] = 0
                    nb_one['all'][direction][app] = 0
                    bytes_one['all'][direction][app] = 0
                    tot_conn['all'][direction][app] = 0
                    tot_bytes['all'][direction][app] = 0

                # Only interested on MPTCP connections
                if isinstance(conn, mptcp.MPTCPConnection):
                    if conn.attr[co.DURATION] < limit_duration:
                        continue
                    conn_bytes_s2d = {'cellular': 0, 'wifi': 0, '?': 0}
                    conn_bytes_d2s = {'cellular': 0, 'wifi': 0, '?': 0}
                    if co.BYTES in conn.attr[co.S2D]:
                        for interface in conn.attr[co.S2D][co.BYTES]:
                            conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                    if co.BYTES in conn.attr[co.D2S]:
                        for interface in conn.attr[co.D2S][co.BYTES]:
                            conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.S2D not in flow.attr or co.D2S not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                    if conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'] > limit_bytes:
                        frac_cell_s2d = (max(0.0, min(1.0, (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi']))))
                        if frac_cell_s2d == 0:
                            nb_zero['all'][co.S2D][app] += 1
                            bytes_zero['all'][co.S2D][app] += conn_bytes_s2d['wifi']
                        elif frac_cell_s2d == 1:
                            nb_one['all'][co.S2D][app] += 1
                            bytes_one['all'][co.S2D][app] += conn_bytes_s2d['cellular']
                        data_frac['all'][co.S2D][app].append(frac_cell_s2d)
                        data_bytes['all'][co.S2D][app].append(conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])
                        tot_conn['all'][co.S2D][app] += 1
                        tot_bytes['all'][co.S2D][app] += conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi']

                    if conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'] > limit_bytes:
                        frac_cell_d2s = max(0.0, min(1.0, ((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi']))))
                        if frac_cell_d2s == 0:
                            nb_zero['all'][co.D2S][app] += 1
                            bytes_zero['all'][co.D2S][app] += conn_bytes_d2s['wifi']
                        elif frac_cell_d2s == 1:
                            nb_one['all'][co.D2S][app] += 1
                            bytes_one['all'][co.D2S][app] += conn_bytes_d2s['cellular']
                        data_frac['all'][co.D2S][app].append(frac_cell_d2s)
                        data_bytes['all'][co.D2S][app].append(conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])
                        tot_conn['all'][co.D2S][app] += 1
                        tot_bytes['all'][co.D2S][app] += conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi']

    data_scatter = {co.S2D: {}, co.D2S: {}}
    for condition in data_bytes:
        for direction in data_bytes[condition]:
            nb_zeros = 0.
            bytes_zeros = 0.
            nb_ones = 0.
            bytes_ones = 0.
            total_conn = 0.
            total_bytes = 0.
            data_scatter[direction][condition] = {}
            for app in data_bytes[condition][direction]:
                data_scatter[direction][condition][app] = zip(data_bytes[condition][direction][app], data_frac[condition][direction][app])
                print(condition, direction, app, "NB ZERO", nb_zero[condition][direction][app], "BYTES ZERO", bytes_zero[condition][direction][app], "NB ONE", nb_one[condition][direction][app], "BYTES ONE", bytes_one[condition][direction][app], file=log_file)
                nb_zeros += nb_zero[condition][direction][app]
                bytes_zeros += bytes_zero[condition][direction][app]
                nb_ones += nb_one[condition][direction][app]
                bytes_ones += bytes_one[condition][direction][app]
                total_conn += tot_conn[condition][direction][app]
                total_bytes += tot_bytes[condition][direction][app]
            if total_bytes > 0 and total_bytes > 0:
                print("TOTAL:", nb_zeros, "zero conns over", total_conn, nb_zeros / total_conn * 100., "%", bytes_zeros, "zero bytes over", total_bytes, bytes_zeros / total_bytes * 100., "%", nb_ones, "connections full cellular", nb_ones / total_conn * 100., "%", bytes_ones, "bytes cellular", bytes_ones / total_bytes * 100., "%", file=log_file)

    co.scatter_plot_with_direction(data_scatter, "Bytes on connection", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, y_to_one=True, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])

    for cond, data_cond in data_frac.iteritems():
        for direction, data_dir in data_cond.iteritems():
            plt.figure()
            fig, ax = plt.subplots()
            apps = data_dir.keys()
            to_plot = []
            for app in apps:
                for point in data_frac[cond][direction][app]:
                    to_plot.append(point)
            if to_plot:
                plt.hist(to_plot, bins=50)
                plt.xlabel("Fraction of bytes on cellular", fontsize=18)
                plt.ylabel("Number of connections", fontsize=18)
                plt.xlim([0.0, 1.0])
                plt.savefig(base_graph_path_bytes + "_hist_" + cond + "_" + direction + ".pdf")
            plt.close()

    for cond, data_cond in data_frac.iteritems():
        for direction, data_dir in data_cond.iteritems():
            plt.figure()
            fig, ax = plt.subplots()
            apps = data_dir.keys()
            to_plot = []
            for app in apps:
                to_plot.append(data_frac[cond][direction][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes on cellular", fontsize=18)
                plt.ylim([0.0, 1.0])
                plt.savefig(base_graph_path_bytes + "_" + cond + "_" + direction + ".pdf")
            plt.close()


def cdf_bytes_all(log_file=sys.stdout):
    base_graph_name_bytes = "cdf_bytes_all"
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)
    tot_bytes = {'all': {'bytes': []}}

    data_frac = {'all': {}}
    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        app = 'all'
        for conn_id, conn in data.iteritems():
            if app not in data_frac['all'][co.S2D]:
                for direction in data_frac['all'].keys():
                    data_frac['all'][direction][app] = []

            # Only interested on MPTCP connections
            elif isinstance(conn, mptcp.MPTCPConnection):
                conn_bytes_s2d = {'cellular': 0, 'wifi': 0, '?': 0}
                conn_bytes_d2s = {'cellular': 0, 'wifi': 0, '?': 0}
                if co.BYTES in conn.attr[co.S2D]:
                    for interface in conn.attr[co.S2D][co.BYTES]:
                        conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                if co.BYTES in conn.attr[co.D2S]:
                    for interface in conn.attr[co.D2S][co.BYTES]:
                        conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                for flow_id, flow in conn.flows.iteritems():
                    if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                        break
                    interface = flow.attr[co.IF]
                    conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                    conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                tot_bytes['all']['bytes'].append(conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])

    co.plot_cdfs_natural(tot_bytes, ['r'], "Bytes", base_graph_path_bytes)


def cdf_rtt_s2d_all(log_file=sys.stdout, min_samples=5, min_bytes=100):
    wifi = "wifi"
    cell = "cellular"
    aggl_res = {'all': {wifi: [], cell: [], '?': []}}
    graph_fname = "rtt_avg_s2d_all.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D not in flow.attr or co.RTT_SAMPLES not in flow.attr[co.S2D]:
                        break
                    if flow.attr[co.S2D][co.RTT_SAMPLES] >= min_samples and flow.attr[co.S2D][co.BYTES] >= min_bytes:
                        aggl_res['all'][flow.attr[co.IF]] += [(flow.attr[co.S2D][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.S2D not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.S2D]:
                    break
                if conn.flow.attr[co.S2D][co.RTT_SAMPLES] >= min_samples and conn.flow.attr[co.S2D][co.BYTES] >= min_bytes:
                    aggl_res['all'][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]

    aggl_res['all'].pop('?', None)

    co.log_outliers(aggl_res, remove=args.remove)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', graph_full_path)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', os.path.splitext(graph_full_path)[0] + '_cut.pdf', xlim=1000)


def cdf_rtt_d2s_all(log_file=sys.stdout, min_samples=5):
    wifi = "wifi"
    cell = "cellular"
    aggl_res = {'all': {wifi: [], cell: [], '?': []}}
    graph_fname = "rtt_avg_d2s_all.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.D2S not in flow.attr or co.RTT_SAMPLES not in flow.attr[co.D2S]:
                        break
                    if flow.attr[co.D2S][co.RTT_SAMPLES] >= min_samples:
                        aggl_res['all'][flow.attr[co.IF]] += [(flow.attr[co.D2S][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.D2S not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.D2S]:
                    break
                if conn.flow.attr[co.D2S][co.RTT_SAMPLES] >= min_samples:
                    aggl_res['all'][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]

    aggl_res['all'].pop('?', None)

    co.log_outliers(aggl_res, remove=args.remove)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', os.path.splitext(graph_full_path)[0] + '.pdf')
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', os.path.splitext(graph_full_path)[0] + '_cut.pdf', xlim=1000)


def difference_rtt_d2s(log_file=sys.stdout, min_bytes=1000000):
    # Computed only on MPTCP connections with 2 subflows and at least 1MB
    results = {'two_sf': {'diff': []}}
    graph_fname = "rtt_avg_diff_2sf.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                if len(conn.flows) == 2:
                    if conn.attr[co.D2S].get(co.BYTES_MPTCPTRACE, 0) >= min_bytes:
                        is_ok = True
                        for flow_id, flow in conn.flows.iteritems():
                            if co.START not in flow.attr:
                                is_ok = False

                        if not is_ok:
                            continue
                        time_init_sf = float('inf')
                        rtt_init_sf = -1.0
                        rtt_second_sf = -1.0
                        for flow_id, flow in conn.flows.iteritems():
                            if flow.attr[co.START] < time_init_sf:
                                time_init_sf = flow.attr[co.START]
                                rtt_second_sf = rtt_init_sf
                                rtt_init_sf = flow.attr[co.D2S][co.RTT_AVG]
                            else:
                                rtt_second_sf = flow.attr[co.D2S][co.RTT_AVG]
                        results['two_sf']['diff'].append(rtt_init_sf - rtt_second_sf)

    co.plot_cdfs_natural(results, ['red', 'blue', 'green', 'black'], 'Initial SF AVG RTT - Second SF AVG RTT', os.path.splitext(graph_full_path)[0] + '.pdf')


def reinject_plot(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "reinject_bytes"
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {'all': {'all': []}}, co.D2S: {'all': {'all': []}}}
    results_packs = {co.S2D: {'all': {'all': []}}, co.D2S: {'all': {'all': []}}}
    for fname, data in multiflow_connections.iteritems():
        for conn_id, conn in data.iteritems():
            reinject_bytes_s2d = 0.0
            reinject_bytes_d2s = 0.0
            reinject_packs_s2d = 0.0
            reinject_packs_d2s = 0.0
            bytes_s2d = 0.0
            bytes_d2s = 0.0
            packs_s2d = 0.0
            packs_d2s = 0.0

            for flow_id, flow in conn.flows.iteritems():
                if co.S2D in flow.attr and co.D2S in flow.attr:
                    if co.REINJ_ORIG_BYTES in flow.attr[co.S2D] and co.REINJ_ORIG_BYTES in flow.attr[co.D2S]:
                        if co.BYTES in flow.attr[co.S2D]:
                            bytes_s2d += flow.attr[co.S2D][co.BYTES]
                        else:
                            continue
                        if co.BYTES in flow.attr[co.D2S]:
                            bytes_d2s += flow.attr[co.D2S][co.BYTES]
                        else:
                            continue
                        reinject_bytes_s2d += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        reinject_bytes_d2s += flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                        reinject_packs_s2d += flow.attr[co.S2D][co.REINJ_ORIG_PACKS]
                        reinject_packs_d2s += flow.attr[co.D2S][co.REINJ_ORIG_PACKS]
                        packs_s2d += flow.attr[co.S2D][co.PACKS]
                        packs_d2s += flow.attr[co.D2S][co.PACKS]

            if bytes_s2d > min_bytes and packs_s2d > 0:
                results[co.S2D]['all']['all'].append(reinject_bytes_s2d / bytes_s2d)
                results_packs[co.S2D]['all']['all'].append(reinject_packs_s2d / packs_s2d)

            if bytes_d2s > min_bytes and packs_d2s > 0:
                if (reinject_bytes_d2s / bytes_d2s) >= 0.5:
                    print("reinj: " + str(reinject_bytes_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                results[co.D2S]['all']['all'].append(reinject_bytes_d2s / bytes_d2s)
                results_packs[co.D2S]['all']['all'].append(reinject_packs_d2s / packs_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            for app in apps:
                to_plot.append(results[direction][condition][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes reinjected", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()
            packs_base_graph_fname = "reinject_packs"
            packs_base_graph_full_path = os.path.join(sums_dir_exp, packs_base_graph_fname)
            plt.figure()
            fig, ax = plt.subplots()
            apps = results_packs[direction][condition].keys()
            to_plot = []
            for app in apps:
                to_plot.append(results_packs[direction][condition][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of packs reinjected", fontsize=18)
                plt.savefig(packs_base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def retrans_plot(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "retrans_bytes"
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {'all': {'all': []}}, co.D2S: {'all': {'all': []}}}
    results_packs = {co.S2D: {'all': {'all': []}}, co.D2S: {'all': {'all': []}}}
    for fname, data in singleflow_connections.iteritems():
        for conn_id, conn in data.iteritems():
            bytes_retrans_s2d = 0.0
            bytes_retrans_d2s = 0.0
            packs_retrans_s2d = 0.0
            packs_retrans_d2s = 0.0
            bytes_s2d = 0.0
            bytes_d2s = 0.0
            packs_s2d = 0.0
            packs_d2s = 0.0

            for flow_id, flow in conn.flows.iteritems():
                if co.S2D in flow.attr and co.D2S in flow.attr:
                    if co.BYTES_RETRANS in flow.attr[co.S2D] and co.BYTES_RETRANS in flow.attr[co.D2S]:
                        if co.BYTES in flow.attr[co.S2D]:
                            bytes_s2d += flow.attr[co.S2D][co.BYTES]
                        else:
                            continue
                        if co.BYTES in flow.attr[co.D2S]:
                            bytes_d2s += flow.attr[co.D2S][co.BYTES]
                        else:
                            continue
                        bytes_retrans_d2s += flow.attr[co.D2S][co.BYTES_RETRANS]
                        bytes_retrans_s2d += flow.attr[co.S2D][co.BYTES_RETRANS]
                        packs_retrans_s2d += flow.attr[co.S2D][co.PACKS_RETRANS]
                        packs_retrans_d2s += flow.attr[co.D2S][co.PACKS_RETRANS]
                        packs_s2d += flow.attr[co.S2D][co.PACKS]
                        packs_d2s += flow.attr[co.D2S][co.PACKS]

            if bytes_s2d > min_bytes and packs_s2d > 0:
                results[co.S2D]['all']['all'].append(bytes_retrans_s2d / bytes_s2d)
                results_packs[co.S2D]['all']['all'].append(bytes_retrans_s2d / packs_s2d)

            if bytes_d2s > min_bytes and packs_d2s > 0:
                if (bytes_retrans_d2s / bytes_d2s) >= 0.5:
                    print("retrans: " + str(bytes_retrans_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                results[co.D2S]['all']['all'].append(bytes_retrans_d2s / bytes_d2s)
                results_packs[co.D2S]['all']['all'].append(bytes_retrans_d2s / packs_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            for app in apps:
                to_plot.append(results[direction][condition][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes retransmitted", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()
            packs_base_graph_fname = "retrans_packs"
            packs_base_graph_full_path = os.path.join(sums_dir_exp, packs_base_graph_fname)
            plt.figure()
            fig, ax = plt.subplots()
            apps = results_packs[direction][condition].keys()
            to_plot = []
            for app in apps:
                to_plot.append(results_packs[direction][condition][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of packs retransmitted", fontsize=18)
                plt.savefig(packs_base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def reinject_plot_relative_to_data(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "reinject_data_bytes"
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {'all': {'all': []}}, co.D2S: {'all': {'all': []}}}
    for fname, data in multiflow_connections.iteritems():
        for conn_id, conn in data.iteritems():
            if co.S2D not in conn.attr or co.D2S not in conn.attr:
                continue
            reinject_bytes_s2d = 0.0
            reinject_bytes_d2s = 0.0
            bytes_s2d = 0.0
            bytes_d2s = 0.0
            if co.BYTES_MPTCPTRACE in conn.attr[co.S2D]:
                bytes_s2d = conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
            if co.BYTES_MPTCPTRACE in conn.attr[co.D2S]:
                bytes_d2s = conn.attr[co.D2S][co.BYTES_MPTCPTRACE]

            # reinject_bytes_s2d = 0
            # reinject_bytes_d2s = 0
            # reinject_packs_s2d = 0
            # reinject_packs_d2s = 0
            for flow_id, flow in conn.flows.iteritems():
                if co.S2D in flow.attr and co.D2S in flow.attr:
                    if co.REINJ_ORIG_BYTES in flow.attr[co.S2D] and co.REINJ_ORIG_BYTES in flow.attr[co.D2S]:
                        reinject_bytes_s2d += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        reinject_bytes_d2s += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]

            if bytes_s2d > min_bytes:
                results[co.S2D]['all']['all'].append(reinject_bytes_s2d / bytes_s2d)

            if bytes_d2s > min_bytes:
                if (reinject_bytes_d2s / bytes_d2s) >= 0.5:
                    print("reinj: " + str(reinject_bytes_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                results[co.D2S]['all']['all'].append(reinject_bytes_d2s / bytes_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            for app in apps:
                to_plot.append(results[direction][condition][app])
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes reinjected from all data bytes", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def fog_plot_cellular_percentage_rtt_wifi(log_file=sys.stdout, limit_duration=0, limit_bytes=0):
    fog_base_graph_name_bytes = "fog_cellular_rtt_wifi"
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Connections': 'orange'}

    data_rtt = {'all': {}}
    data_frac = {'all': {}}
    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in data_rtt:
        data_rtt[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        app = 'Connections'
        for conn_id, conn in data.iteritems():
            if app not in data_frac['all'][co.S2D]:
                for direction in data_frac['all']:
                    data_frac['all'][direction][app] = []
                    data_rtt['all'][direction][app] = []

            # Only interested on MPTCP connections
            if isinstance(conn, mptcp.MPTCPConnection):
                if conn.attr[co.DURATION] < limit_duration:
                    continue
                conn_bytes_s2d = {'cellular': 0, 'wifi': 0, '?': 0}
                conn_bytes_d2s = {'cellular': 0, 'wifi': 0, '?': 0}
                rtt_max_wifi_s2d = None
                rtt_max_wifi_d2s = None
                if co.BYTES in conn.attr[co.S2D]:
                    for interface in conn.attr[co.S2D][co.BYTES]:
                        conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                if co.BYTES in conn.attr[co.D2S]:
                    for interface in conn.attr[co.D2S][co.BYTES]:
                        conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D not in flow.attr or co.D2S not in flow.attr:
                        continue
                    if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                        break
                    interface = flow.attr[co.IF]
                    conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                    conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                    if interface == co.WIFI:
                        if co.RTT_MAX in flow.attr[co.S2D]:
                            rtt_max_wifi_s2d = flow.attr[co.S2D][co.RTT_MAX]
                        if co.RTT_MAX in flow.attr[co.D2S]:
                            rtt_max_wifi_d2s = flow.attr[co.D2S][co.RTT_MAX]

                if conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'] > limit_bytes:
                    # if (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi']) > 0.6:
                    #     print("S2D: " + str((conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])) + " " + str(conn_bytes_s2d['cellular']) + " " + str(conn_bytes_s2d['wifi']) + " " + fname + " " + conn_id + " " + str(conn.attr[co.DURATION]) + " " + conn.flows['0'].attr[co.IF] + " " + str(conn.flows['0'].attr[co.S2D][co.RTT_STDEV]) + " " + conn.flows['1'].attr[co.IF] + " " + str(conn.flows['1'].attr[co.S2D][co.RTT_STDEV]))
                    frac_cell_s2d = (min(1.0, (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])))
                    data_frac['all'][co.S2D][app].append(frac_cell_s2d)
                    data_rtt['all'][co.S2D][app].append(rtt_max_wifi_s2d)

                if conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'] > limit_bytes:
                    # if (conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi']) > 0.6:
                    #     print("D2S: " + str((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])) + " " + str(conn_bytes_d2s['cellular']) + " " + str(conn_bytes_d2s['wifi']) + " " + fname + " " + conn_id + " " + str(conn.attr[co.DURATION]) + " " + conn.flows['0'].attr[co.IF] + " " + str(conn.flows['0'].attr[co.D2S][co.RTT_STDEV]) + " " + conn.flows['1'].attr[co.IF] + " " + str(conn.flows['1'].attr[co.D2S][co.RTT_STDEV]))
                    frac_cell_d2s = min(1.0, ((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])))
                    data_frac['all'][co.D2S][app].append(frac_cell_d2s)
                    data_rtt['all'][co.D2S][app].append(rtt_max_wifi_d2s)

    data_scatter = {co.S2D: {}, co.D2S: {}}
    for condition in data_rtt:
        for direction in data_rtt[condition]:
            data_scatter[direction][condition] = {}
            for app in data_rtt[condition][direction]:
                data_scatter[direction][condition][app] = zip(data_rtt[condition][direction][app], data_frac[condition][direction][app])

    co.scatter_plot_with_direction(data_scatter, "Max RTT on Wi-Fi (ms)", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, log_scale_x=False)


def check_ok(value):
    if value < 0 or value >= 100000000:
        return 0
    return value


def textual_summary_global(log_file=sys.stdout):
    conn_number = {'all': 0}
    tests_number = {'all': 0}
    bytes_number = {'all': {co.S2D: {co.CELL: 0, co.WIFI: 0, '?': 0}, co.D2S: {co.CELL: 0, co.WIFI: 0, '?': 0}}}

    for fname, data in connections.iteritems():
        conn_number['all'] += len(data)
        tests_number['all'] += 1
        for conn_id, conn in data.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                ith = conn.flow.attr[co.IF]
                if ith not in bytes_number['all'][co.S2D]:
                    continue
                for direction in co.DIRECTIONS:
                    bytes_number['all'][direction][ith] += check_ok(conn.flow.attr[direction][co.BYTES])

            elif isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    ith = flow.attr[co.IF]
                    for direction in co.DIRECTIONS:
                        reinjected = 0
                        if direction in flow.attr:
                            if co.REINJ_ORIG in flow.attr[direction]:
                                for start_seq, stop_seq in flow.attr[direction][co.REINJ_ORIG]:
                                    reinjected += stop_seq - start_seq
                            if co.BYTES in flow.attr[direction]:
                                bytes_number['all'][direction][ith] += check_ok(flow.attr[direction][co.BYTES] - reinjected)

    total = 0
    total_tests = 0
    total_s2d = 0
    total_d2s = 0
    for cond, cond_num in conn_number.iteritems():
        print(cond + ": ", cond_num, " connections with ", tests_number[cond], " tests;", file=log_file)
        total += cond_num
        total_tests += tests_number[cond]
        for direction in co.DIRECTIONS:
            ratio = (bytes_number[cond][direction][co.CELL] + 0.0) / (bytes_number[cond][direction][co.WIFI] + bytes_number[cond][direction][co.CELL]) * 100 if bytes_number[cond][direction][co.WIFI] + bytes_number[cond][direction][co.CELL] > 0 else 0
            print(direction, bytes_number[cond][direction][co.CELL], " bytes cell and ", bytes_number[cond][direction][co.WIFI], "bytes wifi (", ratio, "% cell)", file=log_file)
        for ith in [co.WIFI, co.CELL, '?']:
            total_s2d += bytes_number[cond][co.S2D][ith]
            total_d2s += bytes_number[cond][co.D2S][ith]

    total_ratio = (total_s2d + 0.0) / (total_s2d + total_d2s) * 100 if total_s2d + total_d2s > 0 else 0
    print("Total: " + str(total) + " connections with " + str(total_tests) + " tests; " + str(total_s2d) + " bytes S2D and " + str(total_d2s) + " D2S (" + str(total_ratio) + " % s2d)", file=log_file)


def cdf_overhead_retrans_reinj(log_file=sys.stdout):
    results = {co.S2D: {'all': {'Reinjection': [], 'Retransmission': []}}, co.D2S: {'all': {'Reinjection': [], 'Retransmission': []}}}
    results_two = {co.S2D: {'all': []}, co.D2S: {'all': []}}
    graph_fname = "overhead_retrans_reinj_multiflow.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    count_conn = {co.S2D: 0, co.D2S: 0}
    count_reinj = {co.S2D: 0, co.D2S: 0}
    count_reinj_20 = {co.S2D: 0, co.D2S: 0}
    count_retrans_50 = {co.S2D: 0, co.D2S: 0}
    count_retrans = {co.S2D: 0, co.D2S: 0}
    for fname, data in multiflow_connections.iteritems():
        for conn_id, conn in data.iteritems():
            retrans_bytes = {co.S2D: 0, co.D2S: 0}
            reinj_bytes = {co.S2D: 0, co.D2S: 0}
            total_bytes = {co.S2D: 0, co.D2S: 0}
            total_data_bytes = {co.S2D: 0, co.D2S: 0}
            reinj_data_bytes = {co.S2D: 0, co.D2S: 0}

            for flow_id, flow in conn.flows.iteritems():
                for direction in co.DIRECTIONS:
                    if direction not in flow.attr:
                        continue
                    if co.BYTES in flow.attr[direction]:
                        # total_bytes[direction] += flow.attr[direction][co.BYTES_FRAMES_TOTAL]
                        total_bytes[direction] = total_bytes[direction] + flow.attr[direction][co.BYTES]
                        # retrans_bytes[direction] += flow.attr[direction].get(co.BYTES_FRAMES_RETRANS, 0)
                        retrans_bytes[direction] = retrans_bytes[direction] + flow.attr[direction].get(co.BYTES_RETRANS, 0)
                        # reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0) + (flow.attr[direction].get(co.REINJ_ORIG_PACKS, 0) * co.FRAME_MPTCP_OVERHEAD)
                        reinj_bytes[direction] = reinj_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)
                        total_data_bytes[direction] = total_data_bytes[direction] + flow.attr[direction].get(co.BYTES, 0)
                        reinj_data_bytes[direction] = reinj_data_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

            for direction in co.DIRECTIONS:
                if total_bytes[direction] > 0:
                    count_conn[direction] += 1
                    results[direction]['all']['Retransmission'].append((retrans_bytes[direction] + 0.0) / total_data_bytes[direction])
                    if (retrans_bytes[direction] + 0.0) / total_data_bytes[direction] > 0.0:
                        count_retrans[direction] += 1
                    if (retrans_bytes[direction] + 0.0) / total_data_bytes[direction] >= 0.5:
                        count_retrans_50[direction] += 1
                    results[direction]['all']['Reinjection'].append((reinj_data_bytes[direction] + 0.0) / total_data_bytes[direction])
                    if (reinj_data_bytes[direction] + 0.0) / total_data_bytes[direction] > 0.0:
                        count_reinj[direction] += 1
                    if (reinj_data_bytes[direction] + 0.0) / total_data_bytes[direction] >= 0.2:
                        count_reinj_20[direction] += 1
                    results_two[direction]['all'].append([total_data_bytes[direction], reinj_data_bytes[direction]])

    for direction in co.DIRECTIONS:
        print("COUNT FOR DIRECTION", direction, file=log_file)
        print("TOTAL", count_conn[direction], file=log_file)
        print("REINJ", count_reinj[direction], file=log_file)
        print("REINJ 20", count_reinj_20[direction], file=log_file)
        print("RETRA", count_retrans[direction], file=log_file)
        print("RETRA 50", count_retrans_50[direction], file=log_file)

    co.plot_cdfs_with_direction(results, ['red', 'blue'], 'Fraction of total bytes', graph_full_path, natural=True, ylim=0.8)
    co.plot_cdfs_with_direction(results, ['red', 'blue'], 'Fraction of total bytes', os.path.splitext(graph_full_path)[0] + '_cut.pdf', natural=True, ylim=0.8, xlim=1)
    for direction in results_two:
        for condition in results_two[direction]:
            sorted_data = sorted(results_two[direction][condition], key=lambda elem: elem[0])
            to_plot = [[], []]
            i = 0
            for point in sorted_data:
                to_plot[0].append([i, point[0]])
                to_plot[1].append([i, point[1]])
                i += 1
            tot_graph_full_path = os.path.splitext(graph_full_path)[0] + "_details_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(to_plot, ['Total', 'Reinjections'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def list_bytes_all(log_file=sys.stdout):
    graph_fname = "list_bytes.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    results_two = {'both': {'all': []}}
    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            total_data_bytes = 0
            for direction in co.DIRECTIONS:
                if direction not in conn.attr:
                        continue
                if conn.attr[direction].get(co.BYTES_MPTCPTRACE, 0) > 0:
                    total_data_bytes += conn.attr[direction].get(co.BYTES_MPTCPTRACE, 0)
            results_two['both']['all'].append(total_data_bytes)

    for direction in results_two:
        for condition in results_two[direction]:
            sorted_data = sorted(results_two[direction][condition])
            to_plot = [[]]
            i = 0
            for point in sorted_data:
                to_plot[0].append([i, point])
                i += 1
            tot_graph_full_path = os.path.splitext(graph_full_path)[0] + "_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(to_plot, ['Total'], ['b'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def cdf_overhead_retrans_reinj_singleflow(log_file=sys.stdout):
    results = {co.S2D: {'all': {'Reinjection': [], 'Retransmission': []}}, co.D2S: {'all': {'Reinjection': [], 'Retransmission': []}}}
    results_two = {co.S2D: {'all': []}, co.D2S: {'all': []}}
    graph_fname = "overhead_retrans_reinj_singleflow.pdf"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, data in singleflow_connections.iteritems():
        for conn_id, conn in data.iteritems():
            retrans_bytes = {co.S2D: 0, co.D2S: 0}
            reinj_bytes = {co.S2D: 0, co.D2S: 0}
            total_bytes = {co.S2D: 0, co.D2S: 0}
            total_data_bytes = {co.S2D: 0, co.D2S: 0}
            reinj_data_bytes = {co.S2D: 0, co.D2S: 0}

            for flow_id, flow in conn.flows.iteritems():
                for direction in co.DIRECTIONS:
                    if direction not in flow.attr:
                        continue
                    if co.BYTES in flow.attr[direction]:
                        # total_bytes[direction] += flow.attr[direction][co.BYTES_FRAMES_TOTAL]
                        total_bytes[direction] = total_bytes[direction] + flow.attr[direction][co.BYTES]
                        # retrans_bytes[direction] += flow.attr[direction].get(co.BYTES_FRAMES_RETRANS, 0)
                        retrans_bytes[direction] = retrans_bytes[direction] + flow.attr[direction].get(co.BYTES_RETRANS, 0)
                        # reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0) + (flow.attr[direction].get(co.REINJ_ORIG_PACKS, 0) * co.FRAME_MPTCP_OVERHEAD)
                        reinj_bytes[direction] = reinj_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)
                        total_data_bytes[direction] = total_data_bytes[direction] + flow.attr[direction].get(co.BYTES, 0)
                        reinj_data_bytes[direction] = reinj_data_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

            for direction in co.DIRECTIONS:
                if total_bytes[direction] > 0:
                    results[direction]['all']['Retransmission'].append((retrans_bytes[direction] + 0.0) / total_data_bytes[direction])
                    results[direction]['all']['Reinjection'].append((reinj_data_bytes[direction] + 0.0) / total_data_bytes[direction])
                    results_two[direction]['all'].append([total_data_bytes[direction], retrans_bytes[direction]])

    co.plot_cdfs_with_direction(results, ['red', 'blue'], 'Fraction of total bytes', graph_full_path, natural=True, ylim=0.8)
    co.plot_cdfs_with_direction(results, ['red', 'blue'], 'Fraction of total bytes', os.path.splitext(graph_full_path)[0] + '_cut.pdf', natural=True, ylim=0.8, xlim=1)
    for direction in results_two:
        for condition in results_two[direction]:
            sorted_data = sorted(results_two[direction][condition], key=lambda elem: elem[0])
            to_plot = [[], []]
            i = 0
            for point in sorted_data:
                to_plot[0].append([i, point[0]])
                to_plot[1].append([i, point[1]])
                i += 1
            tot_graph_full_path = os.path.splitext(graph_full_path)[0] + "_details_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(to_plot, ['Total', 'Retransmissions'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def plot_total_bytes_reinj_bytes(log_file=sys.stdout):
    results = {co.S2D: {'all': [[], []]}, co.D2S: {'all': [[], []]}}
    results_raw = {co.S2D: {'all': []}, co.D2S: {'all': []}}
    graph_fname = "total_bytes_reinj_bytes"
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                reinj_bytes = {co.S2D: 0, co.D2S: 0}
                total_bytes = {co.S2D: 0, co.D2S: 0}

                for flow_id, flow in conn.flows.iteritems():
                    for direction in co.DIRECTIONS:
                        if direction not in flow.attr:
                            continue
                        if co.BYTES in flow.attr[direction]:
                            total_bytes[direction] += flow.attr[direction][co.BYTES]
                            reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

                for direction in co.DIRECTIONS:
                    results_raw[direction]['all'].append([total_bytes[direction], reinj_bytes[direction]])

    for direction in results_raw:
        for condition in results_raw[direction]:
            results_raw[direction][condition] = sorted(results_raw[direction][condition], key=lambda elem: elem[0])
            i = 0
            for point in results_raw[direction][condition]:
                results[direction][condition][0].append([i, point[0]])
                results[direction][condition][1].append([i, point[1]])
                i += 1

            tot_graph_full_path = graph_full_path + "_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(results[direction][condition], ['Total', 'Reinjections'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def fog_plot_cellular_percentage_all(log_file=sys.stdout, limit_duration=0, limit_bytes=0):
    fog_base_graph_name_bytes = "fog_cellular_all"
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Connections': 'orange'}

    data_frac = {'all': {}}
    data_bytes = {'all': {}}

    for fname, data in connections.iteritems():
        app = 'Connections'
        for conn_id, conn in data.iteritems():
            if app not in data_frac['all']:
                data_frac['all'][app] = []
                data_bytes['all'][app] = []

            # Only interested on MPTCP connections
            if isinstance(conn, mptcp.MPTCPConnection):
                if conn.attr[co.DURATION] < limit_duration:
                    continue
                conn_bytes = {'cellular': 0, 'wifi': 0, '?': 0}
                if co.BYTES in conn.attr[co.S2D]:
                    for interface in conn.attr[co.S2D][co.BYTES]:
                        conn_bytes[interface] += conn.attr[co.S2D][co.BYTES][interface]
                if co.BYTES in conn.attr[co.D2S]:
                    for interface in conn.attr[co.D2S][co.BYTES]:
                        conn_bytes[interface] += conn.attr[co.D2S][co.BYTES][interface]
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D not in flow.attr or co.D2S not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                        break
                    interface = flow.attr[co.IF]
                    conn_bytes[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                    conn_bytes[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                if conn_bytes['cellular'] + conn_bytes['wifi'] > limit_bytes:
                    frac_cell = (max(0.0, min(1.0, (conn_bytes['cellular'] + 0.0) / (conn_bytes['cellular'] + conn_bytes['wifi']))))
                    data_frac['all'][app].append(frac_cell)
                    data_bytes['all'][app].append(conn_bytes['cellular'] + conn_bytes['wifi'])

    data_scatter = {}
    for condition in data_bytes:
        data_scatter[condition] = {}
        for app in data_bytes[condition]:
            data_scatter[condition][app] = zip(data_bytes[condition][app], data_frac[condition][app])

    co.scatter_plot(data_scatter, "Bytes on connection", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, y_to_one=True, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])


def count_mptcp_best_rtt_flow(log_file=sys.stdout):
    wifi_best_avg_rtt = {'all': {co.S2D: 0, co.D2S: 0}}
    cell_best_avg_rtt = {'all': {co.S2D: 0, co.D2S: 0}}
    wifi_best_max_rtt = {'all': {co.S2D: 0, co.D2S: 0}}
    cell_best_max_rtt = {'all': {co.S2D: 0, co.D2S: 0}}

    for fname, data in connections.iteritems():
        for conn_id, conn in data.iteritems():
            # Only interested on MPTCP connections
            if isinstance(conn, mptcp.MPTCPConnection):
                for direction in co.DIRECTIONS:
                    avg_rtt = {co.WIFI: 100000., co.CELL: 100000.}
                    max_rtt = {co.WIFI: 100000., co.CELL: 100000.}
                    for flow_id, flow in conn.flows.iteritems():
                        if direction not in flow.attr or co.RTT_AVG not in flow.attr[direction] or co.RTT_MAX not in flow.attr[direction]:
                            continue
                        avg_rtt[flow.attr[co.IF]] = flow.attr[direction][co.RTT_AVG]
                        max_rtt[flow.attr[co.IF]] = flow.attr[direction][co.RTT_MAX]

                    if avg_rtt[co.WIFI] == 100000. and avg_rtt[co.CELL] == 100000.:
                        continue
                    if avg_rtt[co.WIFI] <= avg_rtt[co.CELL]:
                        wifi_best_avg_rtt['all'][direction] += 1
                    else:
                        cell_best_avg_rtt['all'][direction] += 1
                    if max_rtt[co.WIFI] <= max_rtt[co.CELL]:
                        wifi_best_max_rtt['all'][direction] += 1
                    else:
                        cell_best_max_rtt['all'][direction] += 1

    for condition in wifi_best_avg_rtt:
        for direction in co.DIRECTIONS:
            print(condition, direction, (wifi_best_avg_rtt[condition][direction] + 0.) / (wifi_best_avg_rtt[condition][direction] + cell_best_avg_rtt[condition][direction]) * 100, "% where WiFi is better on average", (wifi_best_max_rtt[condition][direction] + 0.0) / (wifi_best_max_rtt[condition][direction] + cell_best_max_rtt[condition][direction]) * 100 , "% where WiFi is better on max", file=log_file)


def time_reinjection(log_file=sys.stdout):
    location_time = {co.S2D: {'all': {co.REINJ_ORIG_TIMESTAMP: []}}, co.D2S: {'all': {co.REINJ_ORIG_TIMESTAMP: []}}}
    location_time_nocorrect = {co.S2D: {'all': {co.REINJ_ORIG_TIMESTAMP: []}}, co.D2S: {'all': {co.REINJ_ORIG_TIMESTAMP: []}}}
    reinj_first_sec = []
    color = ['red']
    graph_fname = "time_reinjection"
    base_graph_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                start_time = float('inf')
                duration = conn.attr[co.DURATION]
                if duration <= 0.001:
                    continue

                start_time = conn.attr.get(co.START, float('inf'))

                if start_time == float('inf'):
                    continue

                start_time_int = int(start_time)
                start_time_dec = float(str(start_time - start_time_int)[1:])
                start_time_dec = ceil(start_time_dec * 1000000) / 1000000.0
                warning_reinj = open(os.path.join(sums_dir_exp, 'warning_reinj.txt'), 'w')
                look_95 = open(os.path.join(sums_dir_exp, 'look95.txt'), 'w')
                look_100 = open(os.path.join(sums_dir_exp, 'look100.txt'), 'w')
                for direction in [co.D2S]:
                    for flow_id, flow in conn.flows.iteritems():
                        if co.REINJ_ORIG_TIMESTAMP in flow.attr[direction] and co.START in flow.attr:
                            for ts in flow.attr[direction][co.REINJ_ORIG_TIMESTAMP]:
                                # Some tricks to avoid floating errors
                                ts_int = int(ts)
                                ts_dec = float(str(ts - ts_int)[1:])
                                ts_dec = ceil(ts_dec * 1000000) / 1000000.0
                                ts_dec_delta = ts_dec - start_time_dec
                                ts_fix = ts_int - start_time_int + ts_dec_delta
                                location_time[direction]['all'][co.REINJ_ORIG_TIMESTAMP].append(max(min(ts_fix / duration, 1.0), 0.0))
                                location_time_nocorrect[direction]['all'][co.REINJ_ORIG_TIMESTAMP].append(ts_fix / duration)
                                if direction == co.D2S and ts_fix / duration < 0.0 or ts_fix / duration > 1.0:
                                    print(fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=warning_reinj)
                                if direction == co.D2S and ts_fix <= 1.0:
                                    reinj_first_sec.append((conn_id, flow_id))
                                if direction == co.D2S and ts_fix / duration >= 0.92 and ts_fix / duration <= 0.97:
                                    print(fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=look_95)
                                if direction == co.D2S and ts_fix / duration >= 0.99:
                                    print(fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=look_100)

    co.plot_cdfs_with_direction(location_time, color, 'Fraction of connection duration', base_graph_path, natural=True)
    co.plot_cdfs_with_direction(location_time_nocorrect, color, 'Fraction of connection duration', base_graph_path + '_nocorrect', natural=True)
    print(reinj_first_sec, file=log_file)
    print(len(reinj_first_sec), "reinjections in 1 second", file=log_file)
    warning_reinj.close()
    look_95.close()
    look_100.close()


def time_retransmission(log_file=sys.stdout):
    location_time = {co.S2D: {'all': {co.TIMESTAMP_RETRANS: []}}, co.D2S: {'all': {co.TIMESTAMP_RETRANS: []}}}
    location_time_no_correct = {co.S2D: {'all': {co.TIMESTAMP_RETRANS: []}}, co.D2S: {'all': {co.TIMESTAMP_RETRANS: []}}}
    color = ['red']
    graph_fname = "time_retransmission"
    base_graph_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                start_time = float('inf')
                duration = conn.attr[co.DURATION]
                if duration <= 0.001:
                    continue
                start_time = conn.attr.get(co.START, float('inf'))
                for direction in co.DIRECTIONS:
                    for flow_id, flow in conn.flows.iteritems():
                        if co.TIMESTAMP_RETRANS in flow.attr[direction] and co.START in flow.attr:
                            start_flow_time = flow.attr[co.START]
                            time_diff = start_flow_time - start_time
                            for ts in flow.attr[direction][co.TIMESTAMP_RETRANS]:
                                location_time[direction]['all'][co.TIMESTAMP_RETRANS].append(min((ts + time_diff) / duration, 1.0))
                                location_time_no_correct[direction]['all'][co.TIMESTAMP_RETRANS].append((ts + time_diff) / duration)
                                if direction == co.D2S and (ts + time_diff) / duration < 0.0 or (ts + time_diff) / duration > 1.0:
                                    print("WARNING retrans", fname, conn_id, flow_id, ts / duration, file=log_file)

    co.plot_cdfs_with_direction(location_time, color, 'Fraction of connection duration', base_graph_path, natural=True, xlim=1.0)
    co.plot_cdfs_with_direction(location_time, color, 'Fraction of connection duration', base_graph_path + '_nocorrect', natural=True)


def merge_time_reinjection_retransmission(log_file=sys.stdout):
    location_time = {co.S2D: {'all': {"Reinjections": [], "Retransmissions": []}}, co.D2S: {'all': {"Reinjections": [], "Retransmissions": []}}}
    location_time_nocorrect = {co.S2D: {'all': {"Reinjections": [], "Retransmissions": []}}, co.D2S: {'all': {"Reinjections": [], "Retransmissions": []}}}
    reinj_first_sec = []
    color = ['red', 'blue']
    graph_fname = "merge_time_reinjection_retranmission"
    base_graph_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                start_time = float('inf')
                duration = conn.attr[co.DURATION]
                if duration <= 0.001:
                    continue

                start_time = conn.attr.get(co.START, float('inf'))

                if start_time == float('inf'):
                    continue

                start_time_int = int(start_time)
                start_time_dec = float(str(start_time - start_time_int)[1:])
                start_time_dec = ceil(start_time_dec * 1000000) / 1000000.0
                warning_reinj = open(os.path.join(sums_dir_exp, 'warning_reinj.txt'), 'w')
                look_95 = open(os.path.join(sums_dir_exp, 'look95.txt'), 'w')
                look_100 = open(os.path.join(sums_dir_exp, 'look100.txt'), 'w')
                warning_retrans = open(os.path.join(sums_dir_exp, 'warning_retrans.txt'), 'w')
                for direction in [co.D2S]:
                    for flow_id, flow in conn.flows.iteritems():
                        if co.REINJ_ORIG_TIMESTAMP in flow.attr[direction] and co.START in flow.attr:
                            for ts in flow.attr[direction][co.REINJ_ORIG_TIMESTAMP]:
                                # Some tricks to avoid floating errors
                                ts_int = int(ts)
                                ts_dec = float(str(ts - ts_int)[1:])
                                ts_dec = ceil(ts_dec * 1000000) / 1000000.0
                                ts_dec_delta = ts_dec - start_time_dec
                                ts_fix = ts_int - start_time_int + ts_dec_delta
                                location_time[direction]['all']["Reinjections"].append(max(min(ts_fix / duration, 1.0), 0.0))
                                location_time_nocorrect[direction]['all']["Reinjections"].append(ts_fix / duration)
                                if direction == co.D2S and ts_fix / duration < 0.0 or ts_fix / duration > 1.0:
                                    print(fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=warning_reinj)
                                if direction == co.D2S and ts_fix <= 1.0:
                                    reinj_first_sec.append((conn_id, flow_id))
                                if direction == co.D2S and ts_fix / duration >= 0.92 and ts_fix / duration <= 0.97:
                                    print(fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=look_95)
                                if direction == co.D2S and ts_fix / duration >= 0.99:
                                    print("LOOK 100", fname, conn_id, flow_id, ts_fix / duration, ts, start_time, ts_fix, duration, file=log_file)

                start_time = float('inf')
                duration = conn.attr[co.DURATION]
                if duration <= 0.001:
                    continue
                start_time = conn.attr.get(co.START, float('inf'))
                for direction in co.DIRECTIONS:
                    for flow_id, flow in conn.flows.iteritems():
                        if co.TIMESTAMP_RETRANS in flow.attr[direction] and co.START in flow.attr:
                            start_flow_time = flow.attr[co.START]
                            time_diff = start_flow_time - start_time
                            for ts in flow.attr[direction][co.TIMESTAMP_RETRANS]:
                                location_time[direction]['all']["Retransmissions"].append(max(min((ts + time_diff) / duration, 1.0), 0.0))
                                location_time_nocorrect[direction]['all']["Retransmissions"].append((ts + time_diff) / duration)
                                if direction == co.D2S and (ts + time_diff) / duration >= 0.99:
                                    print("LOOK RETRANS", fname, conn_id, flow_id, duration, (ts + time_diff) / duration)
                                # if direction == co.D2S and (ts + time_diff) / duration < 0.0 or (ts + time_diff) / duration > 1.0:
                                #     print(fname, conn_id, flow_id, ts / duration, file=warning_retrans)

    co.plot_cdfs_with_direction(location_time, color, 'Fraction of connection duration', base_graph_path, natural=True)
    co.plot_cdfs_with_direction(location_time_nocorrect, color, 'Fraction of connection duration', base_graph_path + '_nocorrect', natural=True)
    print(reinj_first_sec, file=log_file)
    print(len(reinj_first_sec), "reinjections in 1 second", file=log_file)
    warning_reinj.close()
    look_95.close()
    look_100.close()
    warning_retrans.close()


def total_retrans_reinj(log_file=sys.stdout):
    reinject = {co.S2D: 0, co.D2S: 0}
    reinject_packs = {co.S2D: 0, co.D2S: 0}
    retrans = {co.S2D: 0, co.D2S: 0}
    retrans_packs = {co.S2D: 0, co.D2S: 0}
    reinject_list = {}
    for fname, conns in connections.iteritems():
        reinject_list[fname] = []
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    added = False
                    for direction in co.DIRECTIONS:
                        if direction in flow.attr:
                            if flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0) > 0:
                                if not added:
                                    reinject_list[fname].append(conn_id)
                                    added = True
                                reinject[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)
                                reinject_packs[direction] += flow.attr[direction].get(co.REINJ_ORIG_PACKS, 0)
                            if flow.attr[direction].get(co.BYTES_RETRANS, 0) > 0:
                                retrans[direction] += flow.attr[direction].get(co.BYTES_RETRANS, 0)
                                retrans_packs[direction] += flow.attr[direction].get(co.PACKS_RETRANS, 0)

    for direction in co.DIRECTIONS:
        print("REINJECT", direction, reinject[direction], file=log_file)
        print("REINJECT PACKS", direction, reinject_packs[direction], file=log_file)
        print("RETRANS", direction, retrans[direction], file=log_file)
        print("RETRANS PACKS", direction, retrans_packs[direction], file=log_file)

    print("LIST OF REINJECTION CONNECTIONS", file=log_file)
    print(reinject_list, file=log_file)


def bursts_mptcp(log_file=sys.stdout):
    bursts_mb = {co.S2D: {'all': {'Connections': []}}, co.D2S: {'all': {'Connections': []}}}
    bursts_sec = {co.S2D: {'all': {'Connections': []}}, co.D2S: {'all': {'Connections': []}}}
    bursts_pck = {co.S2D: {'all': {'Connections': []}}, co.D2S: {'all': {'Connections': []}}}
    color = ['red']
    graph_fname_mb = "bursts_mb"
    base_graph_path_mb = os.path.join(sums_dir_exp, graph_fname_mb)
    graph_fname_sec = "bursts_sec"
    base_graph_path_sec = os.path.join(sums_dir_exp, graph_fname_sec)
    graph_fname_pck = "packs_bursts"
    base_graph_path_pck = os.path.join(sums_dir_exp, graph_fname_pck)
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                if conn.attr[co.DURATION] > 0.0 and len(conn.flows) >= 2:
                    duration = conn.attr[co.DURATION]
                    if duration == 0.0:
                        continue
                    for direction in co.DIRECTIONS:
                        if conn.attr[direction].get(co.BYTES_MPTCPTRACE, 0) < 1000000:
                            continue
                        nb_packs = 0
                        for flow_id, flow in conn.flows.iteritems():
                            nb_packs += flow.attr[direction].get(co.PACKS, 0)
                        if conn.attr[direction][co.BYTES_MPTCPTRACE] > 1 and co.BURSTS in conn.attr[direction] and len(conn.attr[direction][co.BURSTS]) > 0:
                            tot_bytes = conn.attr[direction][co.BYTES_MPTCPTRACE] / 1000000.0 # For MBytes
                            bursts_mb[direction]['all']['Connections'].append((len(conn.attr[direction][co.BURSTS]) - 1.0) / tot_bytes)
                            bursts_sec[direction]['all']['Connections'].append((len(conn.attr[direction][co.BURSTS]) - 1.0) / duration)
                            bursts_pck[direction]['all']['Connections'].append(nb_packs / len(conn.attr[direction][co.BURSTS]))

    co.plot_cdfs_with_direction(bursts_mb, color, '# switches / MB of data', base_graph_path_mb, natural=True)
    co.plot_cdfs_with_direction(bursts_sec, color, '# switches / second', base_graph_path_sec, natural=True)
    co.plot_cdfs_with_direction(bursts_pck, color, '# packets / # bursts', base_graph_path_pck, natural=True)
    co.plot_cdfs_with_direction(bursts_mb, color, '# switches / MB of data', base_graph_path_mb + "_cut", xlim=5000, natural=True)
    co.plot_cdfs_with_direction(bursts_sec, color, '# switches / second', base_graph_path_sec + "_cut", xlim=200, natural=True)
    co.plot_cdfs_with_direction(bursts_pck, color, '# packets / # bursts', base_graph_path_pck + "_cut", xlim=1000, natural=True)
    co.plot_cdfs_with_direction(bursts_mb, color, '# switches / MB of data', base_graph_path_mb + "_ccdf", natural=True, xlog=True, ylog=True, ccdf=True)
    co.plot_cdfs_with_direction(bursts_sec, color, '# switches / second', base_graph_path_sec + "_ccdf", natural=True, xlog=True, ylog=True, ccdf=True)
    co.plot_cdfs_with_direction(bursts_pck, color, '# packets / # bursts', base_graph_path_pck + "_ccdf", natural=True, xlog=True, ylog=True, ccdf=True)


def detect_handover(log_file=sys.stdout):
    handover_conns = {}
    for fname, conns in connections.iteritems():
        handover_conns[fname] = []
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                start_time = float('inf')
                for flow_id, flow in conn.flows.iteritems():
                    if co.START not in flow.attr:
                        continue
                    start_time = min(start_time, flow.attr[co.START])
                for flow_id, flow in conn.flows.iteritems():
                    if co.START in flow.attr and flow.attr[co.START] - start_time >= 2.0:
                        handover_conns[fname].append(conn_id)

    print(handover_conns, file=log_file)


def delay_mpcapable_mpjoin_quantify_handover(log_file=sys.stdout, threshold_handover=2.0):
    syn_additional_sfs = []
    handover_conns = {}
    # Look only at multiple subflows connections
    for fname, conns in multiflow_connections.iteritems():
        handover_conns[fname] = {}
        for conn_id, conn in conns.iteritems():
            # First find initial subflow timestamp
            initial_sf_ts = float('inf')
            for flow_id, flow in conn.flows.iteritems():
                if co.START not in flow.attr:
                    continue
                if flow.attr[co.START] < initial_sf_ts:
                    initial_sf_ts = flow.attr[co.START]

            if initial_sf_ts == float('inf'):
                continue

            # Now store the delta and record connections with handover
            handover_detected = False
            for flow_id, flow in conn.flows.iteritems():
                if co.START not in flow.attr:
                    continue
                delta = flow.attr[co.START] - initial_sf_ts
                if delta > 0.0:
                    syn_additional_sfs.append(delta)
                    if delta >= threshold_handover and not handover_detected:
                        handover_detected = True
                        handover_conns[fname][conn_id] = conn
                    if delta >= 50000:
                        print("HUGE DELTA", fname, conn_id, flow_id, delta, file=log_file)

    # Do a first CDF plot of the delta between initial SYN and additional ones
    base_graph_path = os.path.join(sums_dir_exp, 'cdf_delta_addtitional_syns')
    co.plot_cdfs_natural({'multiflow': {'delta': syn_additional_sfs}}, ['red'], 'Seconds', base_graph_path + '_log', xlog=True)
    co.plot_cdfs_natural({'multiflow': {'delta': syn_additional_sfs}}, ['red'], 'Seconds', base_graph_path)
    co.plot_cdfs_natural({'multiflow': {'delta': syn_additional_sfs}}, ['red'], 'Seconds', base_graph_path + '_cut', xlim=5.0)
    co.plot_cdfs_natural({'multiflow': {'delta': syn_additional_sfs}}, ['red'], 'Seconds', base_graph_path + '_cut_15', xlim=15.0)

    # Now quantify in handover connections the amount of data not on the initial subflows
    bytes_init_sf = 0.0
    bytes_init_sfs = 0.0
    bytes_total = 0.0
    for fname, conns in handover_conns.iteritems():
        for conn_id, conn in conns.iteritems():
            # First find initial subflow timestamp
            initial_sf_ts = float('inf')
            for flow_id, flow in conn.flows.iteritems():
                if co.START not in flow.attr:
                    continue
                if flow.attr[co.START] < initial_sf_ts:
                    initial_sf_ts = flow.attr[co.START]

            # Now collect the amount of data on all subflows
            for flow_id, flow in conn.flows.iteritems():
                if co.START not in flow.attr:
                    continue
                delta = flow.attr[co.START] - initial_sf_ts
                for direction in co.DIRECTIONS:
                    bytes_total += flow.attr[direction].get(co.BYTES, 0)
                    if bytes_total >= 1000000000:
                        print("WARNING!!!", fname, conn_id, flow_id, bytes_total, file=log_file)
                    if delta < threshold_handover:
                        # Initial subflows
                        bytes_init_sfs += flow.attr[direction].get(co.BYTES, 0)
                        if delta == 0.0:
                            # Initial subflow
                            bytes_init_sf += flow.attr[direction].get(co.BYTES, 0)

    # Log those values in the log file
    print("QUANTIFY HANDOVER", file=log_file)
    print(bytes_init_sf, "BYTES ON INIT SF", bytes_init_sf * 100 / bytes_total, "%", file=log_file)
    print(bytes_init_sfs, "BYTES ON INIT SFS", bytes_init_sfs * 100 / bytes_total, "%", file=log_file)
    print("TOTAL BYTES", bytes_total, file=log_file)


def table_rtt_d2s(log_file=sys.stdout):
    MPTCP = "MPTCP"
    TCP = "TCP"
    rtt_min = {MPTCP: [], TCP: []}
    rtt_med = {MPTCP: [], TCP: []}
    rtt_avg = {MPTCP: [], TCP: []}
    rtt_75 = {MPTCP: [], TCP: []}
    rtt_90 = {MPTCP: [], TCP: []}
    rtt_95 = {MPTCP: [], TCP: []}
    rtt_97 = {MPTCP: [], TCP: []}
    rtt_98 = {MPTCP: [], TCP: []}
    rtt_99 = {MPTCP: [], TCP: []}
    rtt_max = {MPTCP: [], TCP: []}
    rtt_diff = {MPTCP: [], TCP: []}
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                if conn.attr[co.D2S].get(co.BYTES_MPTCPTRACE, 0) < 1000000:
                    continue
                data_mptcp = conn.attr[co.D2S]
                if co.RTT_MIN in data_mptcp and co.RTT_AVG in data_mptcp and co.RTT_MED in data_mptcp and co.RTT_99P in data_mptcp:
                    rtt_min[MPTCP].append(data_mptcp[co.RTT_MIN])
                    rtt_med[MPTCP].append(data_mptcp[co.RTT_MED])
                    rtt_avg[MPTCP].append(data_mptcp[co.RTT_AVG])
                    rtt_75[MPTCP].append(data_mptcp[co.RTT_75P])
                    rtt_90[MPTCP].append(data_mptcp[co.RTT_90P])
                    rtt_95[MPTCP].append(data_mptcp[co.RTT_95P])
                    rtt_97[MPTCP].append(data_mptcp[co.RTT_97P])
                    rtt_98[MPTCP].append(data_mptcp[co.RTT_98P])
                    rtt_99[MPTCP].append(data_mptcp[co.RTT_99P])
                    rtt_max[MPTCP].append(data_mptcp[co.RTT_MAX])
                    rtt_diff[MPTCP].append(data_mptcp[co.RTT_MAX] - data_mptcp[co.RTT_MIN])

                    for flow_id, flow in conn.flows.iteritems():
                        if flow.attr[co.D2S].get(co.BYTES, 0) < 250000:
                            continue
                        data = flow.attr[co.D2S]
                        if co.RTT_MIN in data and co.RTT_AVG in data and co.RTT_MED in data and co.RTT_99P in data:
                            rtt_min[TCP].append(data[co.RTT_MIN])
                            rtt_med[TCP].append(data[co.RTT_MED])
                            rtt_avg[TCP].append(data[co.RTT_AVG])
                            rtt_75[TCP].append(data[co.RTT_75P])
                            rtt_90[TCP].append(data[co.RTT_90P])
                            rtt_95[TCP].append(data[co.RTT_95P])
                            rtt_97[TCP].append(data[co.RTT_97P])
                            rtt_98[TCP].append(data[co.RTT_98P])
                            rtt_99[TCP].append(data[co.RTT_99P])
                            rtt_max[TCP].append(data[co.RTT_MAX])
                            rtt_diff[TCP].append(data[co.RTT_MAX] - data[co.RTT_MIN])

    print("TABLE RTT", file=log_file)
    print("\hline", file=log_file)
    print("Protocol & Min & Med & Avg & 75^{th} & 90^{th} & 95^{th} & 97^{th} & 98^{th} & 99^{th} & Max & Max - Min \\ ", file=log_file)
    print("\hline", file=log_file)
    print("\hline", file=log_file)
    for protocol in [MPTCP, TCP]:
        print(protocol, "&", np.mean(rtt_min[protocol]), "&", np.mean(rtt_med[protocol]), "&", np.mean(rtt_avg[protocol]), "&", np.mean(rtt_75[protocol]), "&", np.mean(rtt_90[protocol]), "&", np.mean(rtt_95[protocol]), "&", np.mean(rtt_97[protocol]), "&", np.mean(rtt_98[protocol]), "&", np.mean(rtt_99[protocol]), "&", np.mean(rtt_max[protocol]), "&", np.mean(rtt_diff[protocol]), "\\", file=log_file)
        print(protocol, "&", np.median(rtt_min[protocol]), "&", np.median(rtt_med[protocol]), "&", np.median(rtt_avg[protocol]), "&", np.median(rtt_75[protocol]), "&", np.median(rtt_90[protocol]), "&", np.median(rtt_95[protocol]), "&", np.median(rtt_97[protocol]), "&", np.median(rtt_98[protocol]), "&", np.median(rtt_99[protocol]), "&", np.median(rtt_max[protocol]), "&", np.median(rtt_diff[protocol]), "\\", file=log_file)
        print(protocol, "&", np.percentile(rtt_min[protocol], 75), "&", np.percentile(rtt_med[protocol], 75), "&", np.percentile(rtt_avg[protocol], 75), "&", np.percentile(rtt_75[protocol], 75), "&", np.percentile(rtt_90[protocol], 75), "&", np.percentile(rtt_95[protocol], 75), "&", np.percentile(rtt_97[protocol], 75), "&", np.percentile(rtt_98[protocol], 75), "&", np.percentile(rtt_99[protocol], 75), "&", np.percentile(rtt_max[protocol], 75), "&", np.percentile(rtt_diff[protocol], 75), "\\", file=log_file)
        print(protocol, "&", np.percentile(rtt_min[protocol], 90), "&", np.percentile(rtt_med[protocol], 90), "&", np.percentile(rtt_avg[protocol], 90), "&", np.percentile(rtt_75[protocol], 90), "&", np.percentile(rtt_90[protocol], 90), "&", np.percentile(rtt_95[protocol], 90), "&", np.percentile(rtt_97[protocol], 90), "&", np.percentile(rtt_98[protocol], 90), "&", np.percentile(rtt_99[protocol], 90), "&", np.percentile(rtt_max[protocol], 90), "&", np.percentile(rtt_diff[protocol], 90), "\\", file=log_file)
        print(protocol, "&", np.percentile(rtt_min[protocol], 95), "&", np.percentile(rtt_med[protocol], 95), "&", np.percentile(rtt_avg[protocol], 95), "&", np.percentile(rtt_75[protocol], 95), "&", np.percentile(rtt_90[protocol], 95), "&", np.percentile(rtt_95[protocol], 95), "&", np.percentile(rtt_97[protocol], 95), "&", np.percentile(rtt_98[protocol], 95), "&", np.percentile(rtt_99[protocol], 95), "&", np.percentile(rtt_max[protocol], 95), "&", np.percentile(rtt_diff[protocol], 95), "\\", file=log_file)
        print("\hline", file=log_file)


def plot_rtt_d2s(log_file=sys.stdout):
    rtt_min = []
    rtt_avg = []
    rtt_max = []
    rtt_diff = []
    graph_fname_rtt = "rtt_d2s"
    base_graph_path_rtt = os.path.join(sums_dir_exp, graph_fname_rtt)
    for fname, conns in connections.iteritems():
        for conn_id, conn in conns.iteritems():
            # We never know, still check
            if isinstance(conn, mptcp.MPTCPConnection):
                count_flow = 0
                max_flow = 0.0
                min_flow = float('inf')
                for flow_id, flow in conn.flows.iteritems():
                    if flow.attr[co.D2S].get(co.BYTES, 0) < 100000:
                        continue
                    data = flow.attr[co.D2S]
                    if co.RTT_MIN in data and co.RTT_AVG in data:
                        rtt_min.append(data[co.RTT_MIN])
                        rtt_avg.append(data[co.RTT_AVG])
                        rtt_max.append(data[co.RTT_MAX])

                        count_flow += 1
                        max_flow = max(max_flow, data[co.RTT_AVG])
                        min_flow = min(min_flow, data[co.RTT_AVG])

                        if data[co.RTT_MIN] < 1.0:
                            print("LOW RTT", fname, conn_id, flow_id, data[co.RTT_MIN], data[co.RTT_AVG], data[co.RTT_MAX], flow.attr[co.D2S].get(co.RTT_3WHS, 0), flow.attr[co.D2S].get(co.BYTES, 0), flow.attr[co.D2S].get(co.RTT_SAMPLES, 0), flow.attr[co.DADDR], file=log_file)

                if count_flow >= 2:
                    rtt_diff.append(max_flow - min_flow)


    co.plot_cdfs_natural({'all': {"min RTT": rtt_min, "avg RTT": rtt_avg, "max RTT": rtt_max, "max RTT - min RTT": rtt_diff}}, ['red', 'green', 'blue', 'magenta'], "RTT of subflows larger than 100KB (ms)", base_graph_path_rtt, label_order=["min RTT", "avg RTT", "max RTT", "max RTT - min RTT"], xlog=True)


millis = int(round(time.time() * 1000))

log_file = open(os.path.join(sums_dir_exp, 'log_summary-' + str(millis) + '.txt'), 'w')

print("Summary plots", file=log_file)
# fog_plot_with_bytes_wifi_cell_per_condition(log_file=log_file)
# fog_plot_with_packs_wifi_cell_per_condition(log_file=log_file)
# fog_duration_bytes(log_file=log_file)
cdf_duration(log_file=log_file)
cdfs_bytes(log_file=log_file)
cdf_number_subflows(log_file=log_file)
textual_summary(log_file=log_file)
box_plot_cellular_percentage(log_file=log_file, limit_bytes=0)
cdf_bytes_all(log_file=log_file)
# cdf_rtt_s2d_all(log_file=log_file, min_samples=5)
cdf_rtt_d2s_all(log_file=log_file, min_samples=5)
# reinject_plot(log_file=log_file, min_bytes=9999.9)
# reinject_plot_relative_to_data(log_file=log_file, min_bytes=9999.9)
# retrans_plot(log_file=log_file)
# fog_plot_cellular_percentage_rtt_wifi(log_file=log_file)
textual_summary_global(log_file=log_file)
cdf_overhead_retrans_reinj(log_file=log_file)
cdf_overhead_retrans_reinj_singleflow(log_file=log_file)
plot_total_bytes_reinj_bytes(log_file=log_file)
fog_plot_cellular_percentage_all(log_file=log_file)
count_mptcp_best_rtt_flow(log_file=log_file)
count_ip_type(log_file=log_file)
count_packet(log_file=log_file)
count_ports(log_file=log_file)
count_ports_mptcp(log_file=log_file)
count_on_filtered(log_file=log_file)
# time_reinjection(log_file=log_file)
# time_retransmission(log_file=log_file)
merge_time_reinjection_retransmission(log_file=log_file)
bursts_mptcp(log_file=log_file)
detect_handover(log_file=log_file)
list_bytes_all(log_file=log_file)
difference_rtt_d2s(log_file=log_file)
delay_mpcapable_mpjoin_quantify_handover(log_file=log_file, threshold_handover=1.0)
count_unused_subflows(log_file=log_file)
total_retrans_reinj(log_file=log_file)
# table_rtt_d2s(log_file=log_file)
plot_rtt_d2s(log_file=log_file)
log_file.close()
print("End of summary")
