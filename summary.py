#! /usr/bin/python
# -*- coding: utf-8 -*-
#
#  Copyright 2015 Matthieu Baerts & Quentin De Coninck
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#  To install on this machine: matplotlib, numpy

from __future__ import print_function

##################################################
##                   IMPORTS                    ##
##################################################

import argparse
import common as co
import matplotlib
# Do not use any X11 backend
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import mptcp
import numpy as np
import os
import os.path
import pickle
import sys
import tcp
import time

##################################################
##                  ARGUMENTS                   ##
##################################################

parser = argparse.ArgumentParser(
    description="Summarize stat files generated by analyze")
parser.add_argument("-s",
                    "--stat", help="directory where the stat files are stored", default=co.DEF_STAT_DIR+'_'+co.DEF_IFACE)
parser.add_argument("-A",
                    "--aggl", help="directory where data of agglomerated graphs are stored", default=co.DEF_AGGL_DIR+'_'+co.DEF_IFACE)
parser.add_argument('-S',
                    "--sums", help="directory where the summary graphs will be stored", default=co.DEF_SUMS_DIR+'_'+co.DEF_IFACE)
parser.add_argument("-a",
                    "--app", help="application results to summarize", default="")
parser.add_argument(
    "time", help="aggregate data in specified time, in format START,STOP")
parser.add_argument("-d",
                    "--dirs", help="list of directories to aggregate", nargs="+")
parser.add_argument("-c",
                    "--cond", help="(exact) condition to show", default="")
parser.add_argument("-p",
                    "--prot", help="(exact) protocol to show", default="")
parser.add_argument("-r",
                    "--remove", help="if set, remove outliers from dataset", action="store_true")
parser.add_argument("-l",
                    "--load-apps", help="list of applications whose data is loaded", nargs="+")

args = parser.parse_args()

split_agg = args.time.split(',')

if not len(split_agg) == 2 or not co.is_number(split_agg[0]) or not co.is_number(split_agg[1]):
    print("The aggregation argument is not well formatted", file=sys.stderr)
    parser.print_help()
    exit(1)

start_time = split_agg[0]
stop_time = split_agg[1]

if int(start_time) > int(stop_time):
    print("The start time is posterior to the stop time", file=sys.stderr)
    parser.print_help()
    exit(2)

stat_dir_exp = os.path.abspath(os.path.expanduser(args.stat))
aggl_dir_exp = os.path.abspath(os.path.expanduser(args.aggl))
sums_dir_exp = os.path.abspath(os.path.expanduser(args.sums))

co.check_directory_exists(sums_dir_exp)

if args.prot or args.cond:
    sums_dir_exp = os.path.join(sums_dir_exp, args.prot + args.cond)
    co.check_directory_exists(sums_dir_exp)

##################################################
##                 GET THE DATA                 ##
##################################################


def get_app_name_index(fname):
    """ Return the app name index in fname """
    dash_index = fname.index("-")
    us_1_index = fname[:dash_index].rindex("_")
    us_2_index = fname[:us_1_index].rindex("_")
    us_3_index = fname[:us_2_index].rindex("_")
    return us_3_index + 1, us_2_index

def get_experiment_condition(fname):
    """ Return a string of the format protocol_condition (e.g. tcp_both4TCD100m) """
    app_index, end_app_index = get_app_name_index(fname)
    dash_index = fname.index("-")
    end_index = fname[:dash_index].rindex("_")
    return fname[:app_index] + fname[end_app_index + 1:end_index]


def get_app_name(fname):
    """ Return a string of the name of the application """
    dash_index = fname.index("-")
    us_1_index = fname[:dash_index].rindex("_")
    us_2_index = fname[:us_1_index].rindex("_")
    us_3_index = fname[:us_2_index].rindex("_")
    return fname[us_3_index + 1:us_2_index]


def is_app_name(fname, app_name):
    """ Return if string of the name of the application is app_name """
    if not args.app:
        return True
    if app_name in fname:
        app_index = fname.index(app_name)
        end_index = fname[app_index:].index("_")
        return fname[app_index:(app_index + end_index)] == app_name
    return False


def check_in_list(dirpath, dirs):
    """ Check if dirpath is one of the dir in dirs, True if dirs is empty """
    if not dirs:
        return True
    return os.path.basename(dirpath) in dirs


def check_conditions(fname):
    """ Check if conditions are respected to take into account the trace """
    condition = get_experiment_condition(fname)
    return condition.startswith(args.prot) and condition.endswith(args.cond)


def fetch_data(dir_exp):
    co.check_directory_exists(dir_exp)
    dico = {}
    for dirpath, dirnames, filenames in os.walk(dir_exp):
        if check_in_list(dirpath, args.dirs):
            for fname in filenames:
                fname_date = co.get_date_as_int(fname)
                if is_app_name(fname, args.app) and (fname_date and (int(start_time) <= fname_date <= int(stop_time))) and check_conditions(fname) and (not args.load_apps or get_app_name(fname) in args.load_apps):
                    try:
                        stat_file = open(os.path.join(dirpath, fname), 'r')
                        dico[fname] = pickle.load(stat_file)
                        stat_file.close()
                    except IOError as e:
                        print(str(e) + ': skip stat file ' + fname, file=sys.stderr)
    return dico

connections = fetch_data(stat_dir_exp)
if args.app:
    aggl_graphs = fetch_data(aggl_dir_exp)

##################################################
##               PLOTTING RESULTS               ##
##################################################


def count_interesting_connections(data):
    """ Return the number of interesting connections in data """
    count = 0
    tot = 0
    for k, v in data.iteritems():
        if isinstance(v, mptcp.MPTCPConnection):
            for subflow_id, flow in v.flows.iteritems():
                if flow.attr[co.IF]:
                    count += 1
                if flow.attr[co.DADDR]:
                    tot += 1

        elif isinstance(v, tcp.TCPConnection):
            # Check the key k
            # An interesting flow has an IF field
            if v.flow.attr[co.IF]:
                count += 1
            # All flows have a DADDR field
            if v.flow.attr[co.DADDR]:
                tot += 1
    return tot, count


def bar_chart_count_connections(log_file=sys.stdout):
    aggl_res = {}
    tot_lbl = 'Total Connections'
    tot_flw_lbl = 'Total Flows'
    tot_int_lbl = 'Interesting Flows'
    label_names = ['Total Connections', 'Total Flows', 'Interesting Flows']
    color = ['b', 'g', 'r']
    ecolor = ['g', 'r', 'b']
    ylabel = 'Number of connections'
    title = 'Counts of total and interesting connections of ' + args.app
    graph_fname = "count_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        tot_flow, tot_int = count_interesting_connections(data)
        if condition in aggl_res:
            aggl_res[condition][tot_lbl] += [(len(data), fname)]
            aggl_res[condition][tot_flw_lbl] += [(tot_flow, fname)]
            aggl_res[condition][tot_int_lbl] += [(tot_int, fname)]
        else:
            aggl_res[condition] = {
                tot_lbl: [(len(data), fname)], tot_flw_lbl: [(tot_flow, fname)], tot_int_lbl: [(tot_int, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Number of connections', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_bytes(log_file=sys.stdout):
    aggl_res = {}
    tot_lbl = 'Bytes s2d'
    tot_flw_lbl = 'Bytes d2s'
    label_names = ['Bytes s2d', 'Bytes d2s']
    color = ['b', 'g']
    ecolor = ['g', 'r']
    ylabel = 'Bytes'
    title = 'Number of bytes transfered of ' + args.app
    graph_fname = "bytes_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        s2d = 0
        d2s = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                s2d += conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
                d2s += conn.attr[co.D2S][co.BYTES_MPTCPTRACE]
            elif isinstance(conn, tcp.TCPConnection):
                s2d += conn.flow.attr[co.S2D][co.BYTES]
                d2s += conn.flow.attr[co.D2S][co.BYTES]

        if condition in aggl_res:
            aggl_res[condition][tot_lbl] += [(s2d, fname)]
            aggl_res[condition][tot_flw_lbl] += [(d2s, fname)]
        else:
            aggl_res[condition] = {
                tot_lbl: [(s2d, fname)], tot_flw_lbl: [(d2s, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_bytes_s2d_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "Wi-Fi"
    cell = "Cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "Bytes"
    title = "Number of bytes transfered from source to destination by interface of " + args.app
    graph_fname = "iface_s2d_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        wifi_bytes = 0
        cell_bytes = 0
        reinject_bytes_wifi = 0
        reinject_bytes_cell = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D]:
                        break
                    if flow.attr[co.IF] == co.WIFI:
                        reinject_bytes_wifi += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                    elif flow.attr[co.IF] == co.CELL:
                        reinject_bytes_cell += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
            if co.WIFI in conn.attr[co.S2D][co.BYTES]:
                wifi_bytes += conn.attr[co.S2D][co.BYTES][co.WIFI]
            if co.CELL in conn.attr[co.S2D][co.BYTES]:
                cell_bytes += conn.attr[co.S2D][co.BYTES][co.CELL]

        wifi_bytes -= reinject_bytes_wifi
        cell_bytes -= reinject_bytes_cell

        if condition in aggl_res:
            aggl_res[condition][wifi] += [(wifi_bytes, fname)]
            aggl_res[condition][cell] += [(cell_bytes, fname)]
        else:
            aggl_res[condition] = {
                wifi: [(wifi_bytes, fname)], cell: [(cell_bytes, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_bytes_d2s_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "Wi-Fi"
    cell = "Cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "Bytes"
    title = "Number of bytes transfered from destination to source by interface of " + args.app
    graph_fname = "iface_d2s_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        wifi_bytes = 0
        cell_bytes = 0
        reinject_bytes_wifi = 0
        reinject_bytes_cell = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                        break
                    if flow.attr[co.IF] == co.WIFI:
                        reinject_bytes_wifi += flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                    if flow.attr[co.IF] == co.CELL:
                        reinject_bytes_cell += flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
            if co.WIFI in conn.attr[co.D2S][co.BYTES]:
                wifi_bytes += conn.attr[co.D2S][co.BYTES][co.WIFI]
            if co.CELL in conn.attr[co.D2S][co.BYTES]:
                cell_bytes += conn.attr[co.D2S][co.BYTES][co.CELL]

        wifi_bytes -= reinject_bytes_wifi
        cell_bytes -= reinject_bytes_cell

        if condition in aggl_res:
            aggl_res[condition][wifi] += [(wifi_bytes, fname)]
            aggl_res[condition][cell] += [(cell_bytes, fname)]
        else:
            aggl_res[condition] = {
                wifi: [(wifi_bytes, fname)], cell: [(cell_bytes, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_packs_retrans(log_file=sys.stdout):
    aggl_res = {}
    tot_lbl = 'Packs s2d'
    tot_flw_lbl = 'Packs d2s'
    label_names = ['Packs s2d', 'Packs d2s']
    color = ['b', 'g']
    ecolor = ['g', 'r']
    ylabel = 'Packets'
    title = 'Number of packets retransmitted of ' + args.app
    graph_fname = "packs_retrans_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        s2d = 0
        d2s = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    s2d += flow.attr[co.S2D][co.PACKS_RETRANS]
                    d2s += flow.attr[co.D2S][co.PACKS_RETRANS]
            elif isinstance(conn, tcp.TCPConnection):
                s2d += conn.flow.attr[co.S2D][co.PACKS_RETRANS]
                d2s += conn.flow.attr[co.D2S][co.PACKS_RETRANS]
            else:
                print(conn + ": unknown object")
                continue

        if condition in aggl_res.keys():
            aggl_res[condition][tot_lbl] += [(s2d, fname)]
            aggl_res[condition][tot_flw_lbl] += [(d2s, fname)]
        else:
            aggl_res[condition] = {
                tot_lbl: [(s2d, fname)], tot_flw_lbl: [(d2s, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Number of retransmitted packets', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_packs_retrans_s2d_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "Wi-Fi"
    cell = "Cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "Packets"
    title = "Number of packets retransmitted from source to destination by interface of " + args.app
    graph_fname = "packs_retrans_iface_s2d_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        wifi_packs = 0
        cell_packs = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                if conn.flow.attr[co.IF] == co.WIFI:
                    wifi_packs += conn.flow.attr[co.S2D][co.PACKS_RETRANS]
                elif conn.flow.attr[co.IF] == co.CELL:
                    cell_packs += conn.flow.attr[co.S2D][co.PACKS_RETRANS]
            elif isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if flow.attr[co.IF] == co.WIFI:
                        wifi_packs += flow.attr[co.S2D][co.PACKS_RETRANS]
                    elif flow.attr[co.IF] == co.CELL:
                        cell_packs += flow.attr[co.S2D][co.PACKS_RETRANS]
            else:
                print(conn + ": unknown object")
                continue

        if condition in aggl_res:
            aggl_res[condition][wifi] += [(wifi_packs, fname)]
            aggl_res[condition][cell] += [(cell_packs, fname)]
        else:
            aggl_res[condition] = {
                wifi: [(wifi_packs, fname)], cell: [(cell_packs, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Number of retransmitted packets', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_packs_retrans_d2s_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "Wi-Fi"
    cell = "Cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "Packets"
    title = "Number of packets retransmitted from destination to source by interface of " + args.app
    graph_fname = "packs_retrans_iface_d2s_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        wifi_packs = 0
        cell_packs = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                if conn.flow.attr[co.IF] == co.WIFI:
                    wifi_packs += conn.flow.attr[co.D2S][co.PACKS_RETRANS]
                elif conn.flow.attr[co.IF] == co.CELL:
                    cell_packs += conn.flow.attr[co.D2S][co.PACKS_RETRANS]
            elif isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if flow.attr[co.IF] == co.WIFI:
                        wifi_packs += flow.attr[co.D2S][co.PACKS_RETRANS]
                    elif flow.attr[co.IF] == co.CELL:
                        cell_packs += flow.attr[co.D2S][co.PACKS_RETRANS]

        if condition in aggl_res:
            aggl_res[condition][wifi] += [(wifi_packs, fname)]
            aggl_res[condition][cell] += [(cell_packs, fname)]
        else:
            aggl_res[condition] = {
                wifi: [(wifi_packs, fname)], cell: [(cell_packs, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Number of retransmitted packets', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_duration(log_file=sys.stdout):
    aggl_res = {}
    tot_int_lbl = 'Duration'
    label_names = ['Duration']
    color = ['r']
    ecolor = ['b']
    ylabel = 'Number of seconds'
    title = 'Time of connections of ' + args.app
    graph_fname = "duration_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                data = conn.attr
            elif isinstance(conn, tcp.TCPConnection):
                data = conn.flow.attr
            if condition in aggl_res:
                aggl_res[condition][tot_int_lbl] += [(data[co.DURATION], fname)]
            else:
                aggl_res[condition] = {tot_int_lbl: [(data[co.DURATION], fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Seconds', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_duration_all(log_file=sys.stdout):
    aggl_res = {}
    tot_int_lbl = 'Duration'
    label_names = ['Duration']
    color = ['r']
    ecolor = ['b']
    ylabel = 'Number of seconds'
    title = 'Time of scenario of ' + args.app
    graph_fname = "duration_all_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        start = float("inf")
        stop = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    start = min(start, flow.attr[co.START])
                    stop = max(stop, flow.attr[co.START] + conn.attr[co.DURATION])

            elif isinstance(conn, tcp.TCPConnection):
                start = min(start, conn.flow.attr[co.START])
                stop = max(stop, conn.flow.attr[co.START] + conn.flow.attr[co.DURATION])

        if stop - start >= 0:
            if condition in aggl_res:
                aggl_res[condition][tot_int_lbl] += [(stop - start, fname)]
            else:
                aggl_res[condition] = {tot_int_lbl: [(stop - start, fname)]}

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs(aggl_res, ['red', 'blue', 'green', 'black'], 'Seconds', graph_full_path)
    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_rtt_average_s2d_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "RTT (ms)"
    title = "Average RTT from source to destination of " + args.app
    graph_fname = "rtt_avg_s2d_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.RTT_SAMPLES not in flow.attr[co.S2D]:
                        break
                    if flow.attr[co.S2D][co.RTT_SAMPLES] > 0:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.S2D][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.RTT_SAMPLES not in conn.flow.attr[co.S2D]:
                    break
                if conn.flow.attr[co.S2D][co.RTT_SAMPLES] > 0:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)

    for condition in aggl_res:
        for interface in aggl_res[condition]:
            if len(aggl_res[condition][interface]) == 0:
                aggl_res[condition][interface] += [0]

    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_rtt_average_d2s_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "RTT (ms)"
    title = "Average RTT from destination to source of" + args.app
    graph_fname = "rtt_avg_d2s_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.RTT_SAMPLES not in flow.attr[co.D2S]:
                        break
                    if flow.attr[co.D2S][co.RTT_SAMPLES] > 0:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.D2S][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.RTT_SAMPLES not in conn.flow.attr[co.D2S]:
                    break
                if conn.flow.attr[co.D2S][co.RTT_SAMPLES] > 0:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)

    for condition in aggl_res:
        for interface in aggl_res[condition]:
            if len(aggl_res[condition][interface]) == 0:
                aggl_res[condition][interface] += [0]

    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_rtt_stdev_s2d_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "RTT (ms)"
    title = "RTT standard deviation from source to destination of" + args.app
    graph_fname = "rtt_std_s2d_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.RTT_SAMPLES not in flow.attr[co.S2D]:
                        break
                    if flow.attr[co.S2D][co.RTT_SAMPLES] > 1:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.S2D][co.RTT_STDEV], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.RTT_SAMPLES not in conn.flow.attr[co.S2D]:
                    break
                if conn.flow.attr[co.S2D][co.RTT_SAMPLES] > 1:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.S2D][co.RTT_STDEV], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)

    for condition in aggl_res:
        for interface in aggl_res[condition]:
            if len(aggl_res[condition][interface]) == 0:
                aggl_res[condition][interface] += [0]

    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)


def bar_chart_rtt_stdev_d2s_interface(log_file=sys.stdout):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    label_names = [wifi, cell]
    color = ['r', 'b']
    ecolor = ['b', 'r']
    ylabel = "RTT (ms)"
    title = "RTT standard deviation from destination to source of" + args.app
    graph_fname = "rtt_std_d2s_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.RTT_SAMPLES not in flow.attr[co.D2S]:
                        break
                    if flow.attr[co.D2S][co.RTT_SAMPLES] > 1:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.D2S][co.RTT_STDEV], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.RTT_SAMPLES not in conn.flow.attr[co.D2S]:
                    break
                if conn.flow.attr[co.D2S][co.RTT_SAMPLES] > 1:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.D2S][co.RTT_STDEV], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'Bytes', graph_full_path)

    for condition in aggl_res:
        for interface in aggl_res[condition]:
            if len(aggl_res[condition][interface]) == 0:
                aggl_res[condition][interface] += [0]

    co.plot_bar_chart(aggl_res, label_names, color, ecolor, ylabel, title, graph_full_path)

def line_graph_aggl():
    aggl_res = {}
    xlabel = "Time [s]"
    ylabel = "Sequence number"
    title = "Agglomeration of all connections"
    graph_fname_start = "mean_tsg_" + args.app + "_"

    count = {}

    for fname, data_dir in aggl_graphs.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res.keys():
            aggl_res[condition] = {}
            count[condition] = 1.0
        else:
            count[condition] += 1
        for direction, data_if in data_dir.iteritems():
            if direction not in aggl_res[condition].keys():
                aggl_res[condition][direction] = {}
            for interface, data in data_if.iteritems():
                if interface not in aggl_res[condition][direction].keys():
                    aggl_res[condition][direction][interface] = []
                if len(data) > 0 and len(data[0]) > 2:
                    sorted_list = co.sort_and_aggregate(data)
                else:
                    sorted_list = data
                for point in sorted_list:
                    aggl_res[condition][direction][interface].append([point[0], point[1], fname])

    # Now aggregate by condition
    for condition, data_dir in aggl_res.iteritems():
        for direction, data_if in data_dir.iteritems():
            for interface, data in data_if.iteritems():
                aggl_res[condition][direction][interface] = co.sort_and_aggregate(aggl_res[condition][direction][interface])
                final_list = []
                for point in aggl_res[condition][direction][interface]:
                    final_list.append([point[0], point[1] / count[condition]])
                aggl_res[condition][direction][interface] = final_list

            print(condition, direction)
            print(aggl_res[condition][direction])
            co.plot_line_graph(aggl_res[condition][direction].values(),
                               aggl_res[condition][direction].keys(),
                               ['r', 'b'] if len(aggl_res[condition][direction].keys()) == 2 else ['k'],
                               xlabel, ylabel, title,
                               os.path.join(sums_dir_exp, graph_fname_start + condition + "_" + direction + ".pdf"))


def time_completion_big_connections(log_file=sys.stdout, min_bytes=10000):
    results = {co.S2D: {}, co.D2S: {}}
    results_two = {co.S2D: {}, co.D2S: {}}
    base_graph_name_bytes = "boxplot_duration_" + args.app + "_" + start_time + '_' + stop_time
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)

    for direction in co.DIRECTIONS:
        results[direction] = {'WiFi': [], '3G': [], 'MPTCP 3G (3G 100k)': [], 'MPTCP 4G': [], '4G': [], 'MPTCP 4G (WiFi 1M)': []}
        results_two[direction] = {'WiFi': [], '3G': [], 'MPTCP 3G (3G 100k)': [], 'MPTCP 4G': [], '4G': [], 'MPTCP 4G (WiFi 1M)': []}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        fname_date = co.get_date_as_int(fname)
        key = None
        if 'mptcp_fm_' in condition:
            if 'both3' in condition and 20150214 <= fname_date and fname_date <= 20150220:
                key = 'MPTCP 3G (3G 100k)'
            elif 'both4' in condition and 20150326 <= fname_date and fname_date <= 20150327:
                key = 'MPTCP 4G'
            elif 'both4' in condition and ((20150304 <= fname_date and fname_date <= 20150308) or (20150323 <= fname_date and fname_date <= 20150325)):
                key = 'MPTCP 4G (WiFi 1M)'
        else:
            if 'wlan' in condition and ((20150214 <= fname_date and fname_date <= 20150220) or (20150326 <= fname_date and 20150327 >= fname_date)):
                key = 'WiFi'
            elif 'rmnet3' in condition and ((20150304 <= fname_date and fname_date <= 20150308) or (20150323 <= fname_date and 20150325 >= fname_date)):
                key = '3G'
            elif 'rmnet4' in condition and ((20150304 <= fname_date and fname_date <= 20150308) or (20150323 <= fname_date and 20150325 >= fname_date)):
                key = '4G'

        if key:
            for conn_id, conn in data.iteritems():
                if isinstance(conn, tcp.TCPConnection):
                    for direction in co.DIRECTIONS:
                        if direction in conn.flow.attr:
                            if conn.flow.attr[direction][co.BYTES] >= min_bytes:
                                results[direction][key].append(conn.flow.attr[co.DURATION])
                                results_two[direction][key].append((conn.flow.attr[direction][co.BYTES] + 0.0) / conn.flow.attr[co.DURATION])
                elif isinstance(conn, mptcp.MPTCPConnection):
                    for direction in co.DIRECTIONS:
                        if direction in conn.attr:
                            if co.BYTES_MPTCPTRACE in conn.attr[direction] and conn.attr[direction][co.BYTES_MPTCPTRACE] > min_bytes:
                                results[direction][key].append(conn.attr[co.DURATION])
                                results_two[direction][key].append((conn.attr[direction][co.BYTES_MPTCPTRACE] + 0.0) / conn.attr[co.DURATION])


    for direction, data_dir in results.iteritems():
        plt.figure()
        fig, ax = plt.subplots()
        to_plot = []
        conds = ['WiFi', '3G', '4G', 'MPTCP 4G (WiFi 1M)', 'MPTCP 3G (3G 100k)', 'MPTCP 4G']
        for cond in ['WiFi', '3G', '4G', 'MPTCP 4G (WiFi 1M)', 'MPTCP 3G (3G 100k)', 'MPTCP 4G']:
            to_plot.append(results[direction][cond])
        if to_plot:
            plt.boxplot(to_plot)
            plt.xticks(range(1, len(conds) + 1), conds)
            plt.tick_params(axis='both', which='major', labelsize=7)
            plt.tick_params(axis='both', which='minor', labelsize=5)
            plt.ylabel("Duration [s]", fontsize=18)
            plt.savefig(base_graph_path_bytes + "_" + direction + ".pdf")
        plt.close()

    for direction, data_dir in results_two.iteritems():
        plt.figure()
        fig, ax = plt.subplots()
        to_plot = []
        conds = ['WiFi', '3G', '4G', 'MPTCP 4G (WiFi 1M)', 'MPTCP 3G (3G 100k)', 'MPTCP 4G']
        for cond in ['WiFi', '3G', '4G', 'MPTCP 4G (WiFi 1M)', 'MPTCP 3G (3G 100k)', 'MPTCP 4G']:
            to_plot.append(results_two[direction][cond])
        if to_plot:
            plt.boxplot(to_plot)
            plt.xticks(range(1, len(conds) + 1), conds)
            plt.tick_params(axis='both', which='major', labelsize=7)
            plt.tick_params(axis='both', which='minor', labelsize=5)
            plt.ylabel("Throughput [Bytes/s]", fontsize=18)
            plt.savefig(base_graph_path_bytes + "_throughput_" + direction + ".pdf")
        plt.close()


def percentage_cell_by_app_with_conditions(log_file=sys.stdout):
    xlabels = ['dailymotion', 'drive', 'dropbox', 'facebook', 'firefox', 'firefoxspdy', 'messenger', 'spotify', 'youtube']
    x = range(len(xlabels))

    marks = {co.S2D: 'o', co.D2S: 's'}

    y_datas_bytes = {co.S2D: {}, co.D2S: {}}
    y_datas_packs = {co.S2D: {}, co.D2S: {}}

    color = {'both3': 'b', 'both4': 'g'}
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            app = get_app_name(fname)
            for conn_id, conn in data.iteritems():
                if condition not in y_datas_bytes[co.S2D]:
                    for direction in y_datas_bytes:
                        y_datas_bytes[direction][condition] = {'dailymotion': {}, 'drive': {}, 'dropbox': {}, 'facebook': {}, 'firefox': {}, 'firefoxspdy': {}, 'messenger': {}, 'spotify':{}, 'youtube': {}}
                        y_datas_packs[direction][condition] = {'dailymotion': {}, 'drive': {}, 'dropbox': {}, 'facebook': {}, 'firefox': {}, 'firefoxspdy': {}, 'messenger': {}, 'spotify':{}, 'youtube': {}}
                        for app_name in y_datas_bytes[direction][condition]:
                            y_datas_bytes[direction][condition][app_name] = {co.WIFI: 0, co.CELL: 0}
                            y_datas_packs[direction][condition][app_name] = {co.WIFI: 0, co.CELL: 0}

                if isinstance(conn, tcp.TCPConnection):
                    interface = conn.flow.attr[co.IF]
                    y_datas_bytes[co.S2D][condition][app][interface] += conn.attr[co.S2D][co.BYTES]
                    y_datas_bytes[co.D2S][condition][app][interface] += conn.attr[co.D2S][co.BYTES]
                    if co.PACKS in conn.attr[co.S2D] and co.PACKS in conn.attr[co.D2S]:
                        y_datas_packs[co.S2D][condition][app][interface] += conn.attr[co.S2D][co.PACKS]
                        y_datas_packs[co.D2S][condition][app][interface] += conn.attr[co.D2S][co.PACKS]
                elif isinstance(conn, mptcp.MPTCPConnection):
                    for interface in conn.attr[co.S2D][co.BYTES]:
                        y_datas_bytes[co.S2D][condition][app][interface] += conn.attr[co.S2D][co.BYTES][interface]
                    for interface in conn.attr[co.D2S][co.BYTES]:
                        y_datas_bytes[co.D2S][condition][app][interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        y_datas_bytes[co.S2D][condition][app][interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        y_datas_bytes[co.D2S][condition][app][interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                        if co.PACKS in flow.attr[co.S2D] and co.PACKS in flow.attr[co.D2S]:
                            y_datas_packs[co.S2D][condition][app][interface] += flow.attr[co.S2D][co.PACKS]
                            y_datas_packs[co.D2S][condition][app][interface] += flow.attr[co.D2S][co.PACKS]

    for direction in y_datas_bytes.keys():
        print("cellular percentage for " + direction + ":", file=log_file)
        plt.figure()
        plt.clf()
        fig, ax = plt.subplots()

        for condition in y_datas_bytes[direction]:
            print("For " + condition + ":", file=log_file)
            points = []
            loc_x = list(x)
            # Suppose condition starts with mptcp_fm_
            cond = condition[9:]
            count = 0
            to_pop = []
            for app in xlabels:
                if y_datas_bytes[direction][condition][app][co.CELL] == 0 and y_datas_bytes[direction][condition][app][co.WIFI] == 0:
                    to_pop.append(count)
                else:
                    point = (y_datas_bytes[direction][condition][app][co.CELL] + 0.) / (y_datas_bytes[direction][condition][app][co.CELL] + y_datas_bytes[direction][condition][app][co.WIFI])
                    points.append(point)
                    print(app + " & " + str(point) + " \\", file=log_file)
                count += 1

            for i in reversed(to_pop):
                loc_x.pop(i)

            ax.plot(loc_x, points, marks[direction], color=color[cond], label=cond)

        # Shrink current axis by 20%
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * 0.5, box.height])

        # Put a legend to the right of the current axis
        ax.legend(loc='center right', bbox_to_anchor=(1, 0.5), fontsize='x-small')

        # You can specify a rotation for the tick labels in degrees or with keywords.
        plt.xticks(x, xlabels, rotation='vertical')
        plt.ylabel("Fraction of bytes on cellular", fontsize=16)
        plt.ylim(ymin=0, ymax=1)
        # Pad margins so that markers don't get clipped by the axes
        plt.margins(0.5)
        # Tweak spacing to prevent clipping of tick-labels
        plt.subplots_adjust(bottom=0.2)

        graph_fname = "summary_percentage_bytes_cellular_" + direction + "_" + start_time + '_' + stop_time + ".pdf"
        graph_full_path = os.path.join(sums_dir_exp, graph_fname)

        plt.savefig(graph_full_path)
        plt.clf()
        plt.close('all')

    for direction in y_datas_packs:
        plt.figure()
        plt.clf()
        fig, ax = plt.subplots()

        for condition in y_datas_packs[direction]:
            points = []
            loc_x = list(x)
            # Suppose condition starts with mptcp_fm_
            cond = condition[9:]
            count = 0
            to_pop = []
            for app in xlabels:
                if y_datas_packs[direction][condition][app][co.CELL] == 0 and y_datas_packs[direction][condition][app][co.WIFI] == 0:
                    to_pop.append(count)
                else:
                    point = (y_datas_packs[direction][condition][app][co.CELL] + 0.) / (y_datas_packs[direction][condition][app][co.CELL] + y_datas_packs[direction][condition][app][co.WIFI])
                    points.append(point)
                count += 1

            for i in reversed(to_pop):
                loc_x.pop(i)

            ax.plot(loc_x, points, marks[direction], color=color[cond], label=cond)

        # Shrink current axis by 20%
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * 0.5, box.height])

        # Put a legend to the right of the current axis
        ax.legend(loc='center right', bbox_to_anchor=(1, 0.5), fontsize='x-small')

        # You can specify a rotation for the tick labels in degrees or with keywords.
        plt.xticks(x, xlabels, rotation='vertical')
        plt.ylabel("Fraction of packets on cellular", fontsize=16)
        plt.ylim(ymin=0, ymax=1)
        # Pad margins so that markers don't get clipped by the axes
        plt.margins(0.5)
        # Tweak spacing to prevent clipping of tick-labels
        plt.subplots_adjust(bottom=0.2)
        graph_fname = "summary_percentage_packs_cellular_" + direction + "_" + start_time + '_' + stop_time + ".pdf"
        graph_full_path = os.path.join(sums_dir_exp, graph_fname)

        plt.savefig(graph_full_path)
        plt.clf()
        plt.close('all')


def percentage_cell_by_condition_with_apps(log_file=sys.stdout):
    xlabels = ['both3', 'both4']
    x = range(len(xlabels))

    marks = {co.S2D: 'o', co.D2S: 's'}

    y_datas_bytes = {co.S2D: {}, co.D2S: {}}
    y_datas_packs = {co.S2D: {}, co.D2S: {}}

    color = {'dailymotion': 'brown', 'drive': 'm', 'dropbox': 'y', 'facebook': 'c', 'firefox': 'orange', 'firefoxspdy': 'g', 'messenger': 'b', 'spotify': 'k', 'youtube': 'r'}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname)
            for conn_id, conn in data.iteritems():
                if app not in y_datas_bytes[co.S2D]:
                    for direction in y_datas_bytes:
                        y_datas_bytes[direction][app] = {'both3': {}, 'both4': {}}
                        y_datas_packs[direction][app] = {'both3': {}, 'both4': {}}
                        for cond_name in y_datas_bytes[direction][app]:
                            y_datas_bytes[direction][app][cond_name] = {co.WIFI: 0, co.CELL: 0}
                            y_datas_packs[direction][app][cond_name] = {co.WIFI: 0, co.CELL: 0}

                if isinstance(conn, tcp.TCPConnection):
                    interface = conn.flow.attr[co.IF]
                    y_datas_bytes[co.S2D][app][condition][interface] += conn.attr[co.S2D][co.BYTES]
                    y_datas_bytes[co.D2S][app][condition][interface] += conn.attr[co.D2S][co.BYTES]
                    if co.PACKS in conn.attr[co.S2D] and co.PACKS in conn.attr[co.D2S]:
                        y_datas_packs[co.S2D][app][condition][interface] += conn.attr[co.S2D][co.PACKS]
                        y_datas_packs[co.D2S][app][condition][interface] += conn.attr[co.D2S][co.PACKS]
                elif isinstance(conn, mptcp.MPTCPConnection):
                    for interface in conn.attr[co.S2D][co.BYTES]:
                        y_datas_bytes[co.S2D][app][condition][interface] += conn.attr[co.S2D][co.BYTES][interface]
                    for interface in conn.attr[co.D2S][co.BYTES]:
                        y_datas_bytes[co.D2S][app][condition][interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        y_datas_bytes[co.S2D][app][condition][interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        y_datas_bytes[co.D2S][app][condition][interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                        if co.PACKS in flow.attr[co.S2D] and co.PACKS in flow.attr[co.D2S]:
                            y_datas_packs[co.S2D][app][condition][interface] += flow.attr[co.S2D][co.PACKS]
                            y_datas_packs[co.D2S][app][condition][interface] += flow.attr[co.D2S][co.PACKS]

    for direction in y_datas_bytes:
        plt.figure()
        plt.clf()
        fig, ax = plt.subplots()
        for app in y_datas_bytes[direction]:
            points = []
            loc_x = list(x)
            count = 0
            to_pop = []
            for cond in xlabels:
                if cond not in y_datas_bytes[direction][app] or y_datas_bytes[direction][app][cond][co.CELL] == 0 and y_datas_bytes[direction][app][cond][co.WIFI] == 0:
                    to_pop.append(count)
                else:
                    point = (y_datas_bytes[direction][app][cond][co.CELL] + 0.) / (y_datas_bytes[direction][app][cond][co.CELL] + y_datas_bytes[direction][app][cond][co.WIFI])
                    points.append(point)
                count += 1

            for i in reversed(to_pop):
                loc_x.pop(i)

            ax.plot(loc_x, points, marks[direction], color=color[app], label=app)

        # Shrink current axis by 20%
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * 0.5, box.height])

        # Put a legend to the right of the current axis
        ax.legend(loc='center right', bbox_to_anchor=(1, 0.5), fontsize='x-small')

        # You can specify a rotation for the tick labels in degrees or with keywords.
        plt.xticks(x, xlabels, rotation='vertical')
        plt.ylabel("Fraction of bytes on cellular", fontsize=16)
        plt.ylim(ymin=0, ymax=1)
        # Pad margins so that markers don't get clipped by the axes
        plt.margins(0.5)
        # Tweak spacing to prevent clipping of tick-labels
        plt.subplots_adjust(bottom=0.25)

        graph_fname = "summary_percentage_bytes_cellular_reversed_" + direction + "_" + start_time + '_' + stop_time + ".pdf"
        graph_full_path = os.path.join(sums_dir_exp, graph_fname)

        plt.savefig(graph_full_path)
        plt.clf()
        plt.close('all')

    for direction in y_datas_packs:
        plt.figure()
        plt.clf()
        fig, ax = plt.subplots()
        for app in y_datas_packs[direction]:
            points = []
            loc_x = list(x)
            count = 0
            to_pop = []
            for cond in xlabels:
                if cond not in y_datas_packs[direction][app] or y_datas_packs[direction][app][cond][co.CELL] == 0 and y_datas_packs[direction][app][cond][co.WIFI] == 0:
                    to_pop.append(count)
                else:
                    point = (y_datas_packs[direction][app][cond][co.CELL] + 0.) / (y_datas_packs[direction][app][cond][co.CELL] + y_datas_packs[direction][app][cond][co.WIFI])
                    points.append(point)
                count += 1

            for i in reversed(to_pop):
                loc_x.pop(i)

            ax.plot(loc_x, points, marks[direction], color=color[app], label=app)

        # Shrink current axis by 20%
        box = ax.get_position()
        ax.set_position([box.x0, box.y0, box.width * 0.5, box.height])

        # Put a legend to the right of the current axis
        ax.legend(loc='center right', bbox_to_anchor=(1, 0.5), fontsize='x-small')

        # You can specify a rotation for the tick labels in degrees or with keywords.
        plt.xticks(x, xlabels, rotation='vertical')
        plt.ylabel("Fraction of packets on cellular", fontsize=16)
        plt.ylim(ymin=0, ymax=1)
        # Pad margins so that markers don't get clipped by the axes
        plt.margins(0.5)
        # Tweak spacing to prevent clipping of tick-labels
        plt.subplots_adjust(bottom=0.25)
        graph_fname = "summary_percentage_packs_cellular_reversed_" + direction + "_" + start_time + '_' + stop_time + ".pdf"
        graph_full_path = os.path.join(sums_dir_exp, graph_fname)

        plt.savefig(graph_full_path)
        plt.clf()
        plt.close('all')


def nb_conns_by_app(log_file=sys.stdout):
    xlabels = ['dailymotion', 'drive', 'dropbox', 'facebook', 'firefox', 'firefoxspdy', 'messenger', 'spotify', 'youtube']
    data = {}

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)
        app = get_app_name(fname)
        if condition not in data:
            data[condition] = {}
        if app not in data[condition]:
            data[condition][app] = []
        data[condition][app].append(len(conns))

    for condition, data_app in data.iteritems():
        to_pop = []
        to_plot_mean = []
        to_plot_std = []
        xlabels_loc = list(xlabels)

        count = 0
        for app_name in xlabels_loc:
            if app_name in data[condition]:
                np_array = np.array(data[condition][app_name])
                to_plot_mean.append(np_array.mean())
                to_plot_std.append(np_array.std())
            else:
                to_pop.append(count)
            count += 1

        for i in reversed(to_pop):
            xlabels_loc.pop(i)

        plt.figure()
        plt.clf()
        width = 0.35
        ind = np.arange(len(to_plot_mean))
        plt.bar(ind, to_plot_mean, width, yerr=to_plot_std, ecolor="r", log=True)
        plt.xticks(ind + width / 2, xlabels_loc, rotation='vertical')
        plt.ylabel("Total number of connections", fontsize=16)
        # Pad margins so that markers don't get clipped by the axes
        plt.margins(0.2)
        # Tweak spacing to prevent clipping of tick-labels
        plt.subplots_adjust(bottom=0.2)
        graph_fname = "summary_connection_" + condition + '_' + start_time + '_' + stop_time + ".pdf"
        graph_full_path = os.path.join(sums_dir_exp, graph_fname)

        plt.savefig(graph_full_path)
        plt.clf()
        plt.close('all')


def fog_plot_with_bytes_wifi_cell_per_condition(log_file=sys.stdout):
    data = {co.S2D: {}, co.D2S: {}}
    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}
    base_graph_name = "fog_bytes_" + start_time + '_' + stop_time

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' not in condition or 'mptcp' not in condition:
            # No point to do this for one-flow connections
            continue
        app = get_app_name(fname).title()
        if condition not in data[co.S2D]:
            data[co.S2D][condition] = {}
            data[co.D2S][condition] = {}
        if app not in data[co.S2D][condition]:
            data[co.S2D][condition][app] = []
            data[co.D2S][condition][app] = []

        for conn_id, conn in conns.iteritems():
            if co.BYTES in conn.attr[co.S2D]:
                data[co.S2D][condition][app].append([conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0), conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)])
            if co.BYTES in conn.attr[co.D2S]:
                data[co.D2S][condition][app].append([conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0), conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)])

    co.scatter_plot_with_direction(data, "Bytes on Wi-Fi", "Bytes on cellular", color, sums_dir_exp, base_graph_name)


def fog_plot_with_packs_wifi_cell_per_condition(log_file=sys.stdout):
    data = {co.S2D: {}, co.D2S: {}}
    color = {'dailymotion': 'brown', 'drive': 'm', 'dropbox': 'y', 'facebook': 'c', 'firefox': 'orange', 'firefoxspdy': 'g', 'messenger': 'b', 'spotify': 'k', 'youtube': 'r'}
    base_graph_name = "fog_packs_" + start_time + '_' + stop_time

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' not in condition or 'mptcp' not in condition:
            # No point to do this for one-flow connections
            continue
        app = get_app_name(fname)
        if condition not in data[co.S2D]:
            data[co.S2D][condition] = {}
            data[co.D2S][condition] = {}
        if app not in data[co.S2D][condition]:
            data[co.S2D][condition][app] = []
            data[co.D2S][condition][app] = []

        for conn_id, conn in conns.iteritems():
            # conn is then a MPTCPConnection, be still better to be sure of
            if isinstance(conn, mptcp.MPTCPConnection):
                packs = {co.S2D: {co.CELL: 0, co.WIFI: 0}, co.D2S: {co.CELL: 0, co.WIFI: 0}}
                for flow_id, flow in conn.flows.iteritems():
                    if not co.S2D in flow.attr:
                        continue
                    if co.PACKS not in flow.attr[co.S2D] or co.PACKS not in flow.attr[co.D2S]:
                        break
                    interface = flow.attr[co.IF]
                    packs[co.S2D][interface] += flow.attr[co.S2D][co.PACKS]
                    packs[co.D2S][interface] += flow.attr[co.D2S][co.PACKS]

                if packs[co.S2D][co.CELL] == 0 and packs[co.S2D][co.WIFI] == 0 and packs[co.D2S][co.CELL] == 0 and packs[co.D2S][co.WIFI] == 0:
                    continue

                data[co.S2D][condition][app].append([packs[co.S2D][co.WIFI], packs[co.S2D][co.CELL]])
                data[co.D2S][condition][app].append([packs[co.D2S][co.WIFI], packs[co.D2S][co.CELL]])

    co.scatter_plot_with_direction(data, "Packets on wifi", "Packets on cellular", color, sums_dir_exp, base_graph_name)


def fog_duration_bytes(log_file=sys.stdout):
    # data = {co.S2D: {}, co.D2S: {}}
    data = {}
    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Firefoxspdy': 'g', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}
    base_graph_name = "fog_duration_bytes_" + start_time + '_' + stop_time

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)
        app = get_app_name(fname).title()
        if condition not in data:
            data[condition] = {}
        if app not in data[condition]:
            data[condition][app] = []

        for conn_id, conn in conns.iteritems():
            # conn is then a BasicConnection
            duration = 0
            if isinstance(conn, tcp.TCPConnection):
                if co.DURATION not in conn.flow.attr:
                    print("ERROR: missing key " + conn_id + " " + fname)
                else:
                    duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                if co.DURATION not in conn.attr:
                    print("ERROR: missing key " + conn_id + " " + fname)
                else:
                    duration = conn.attr[co.DURATION]
            nb_bytes = 0
            if co.BYTES in conn.attr[co.S2D]:
                nb_bytes = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)
            if co.BYTES in conn.attr[co.D2S]:
                nb_bytes += conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)
            data[condition][app].append([duration, nb_bytes])

    co.scatter_plot(data, "Duration [s]", "Bytes on connection", color, sums_dir_exp, base_graph_name, plot_identity=False, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])


def cdfs_summary(log_file=sys.stdout):
    data_duration = {}
    data_bytes = {}
    data_bytes_with_dir = {co.S2D: {}, co.D2S: {}}
    color = ['red', 'blue', 'green', 'black']
    base_graph_name_duration = "summary_cdf_duration_" + start_time + '_' + stop_time
    base_graph_name_bytes = "summary_cdf_bytes_" + start_time + '_' + stop_time
    base_graph_path_duration = os.path.join(sums_dir_exp, base_graph_name_duration)
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)

        if condition not in data_duration:
            data_duration[condition] = {co.DURATION: []}
            data_bytes[condition] = {'bytes': []}
            data_bytes_with_dir[co.S2D][condition] = {co.BYTES: []}
            data_bytes_with_dir[co.D2S][condition] = {co.BYTES: []}

        for conn_id, conn in conns.iteritems():
            # conn is then a BasicConnection
            duration = 0
            if isinstance(conn, tcp.TCPConnection):
                duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                duration = conn.attr[co.DURATION]
            if co.BYTES in conn.attr[co.S2D]:
                nb_bytes_s2d = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)
            if co.BYTES in conn.attr[co.D2S]:
                nb_bytes_d2s = conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)

            data_duration[condition][co.DURATION].append(duration)
            data_bytes[condition]['bytes'].append(nb_bytes_s2d + nb_bytes_d2s)
            data_bytes_with_dir[co.S2D][condition][co.BYTES].append(nb_bytes_s2d)
            data_bytes_with_dir[co.D2S][condition][co.BYTES].append(nb_bytes_d2s)

    co.plot_cdfs_natural(data_duration, color, 'Seconds [s]', base_graph_path_duration)
    co.plot_cdfs_natural(data_bytes, color, 'Bytes', base_graph_path_bytes)
    co.plot_cdfs_with_direction(data_bytes_with_dir, color, 'Bytes', base_graph_path_bytes, natural=True)


def textual_summary(log_file=sys.stdout):
    data = {}
    count = {}
    tot_count = {}

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)

        if condition not in data.keys():
            data[condition] = {'<1s': 0, '1-30s': 0, '30-60s': 0, '>=60s': 0}
            count[condition] = {'<1s': 0, '1-30s': 0, '30-60s': 0, '>=60s': 0}
            tot_count[condition] = 0.0

        for conn_id, conn in conns.iteritems():
            # conn is then a BasicConnection
            duration = 0
            if isinstance(conn, tcp.TCPConnection):
                duration = conn.flow.attr[co.DURATION]
            elif isinstance(conn, mptcp.MPTCPConnection):
                duration = conn.attr[co.DURATION]

            nb_bytes_s2d = 0
            nb_bytes_d2s = 0

            if co.BYTES in conn.attr[co.S2D]:
                nb_bytes_s2d = conn.attr[co.S2D][co.BYTES].get(co.WIFI, 0) + conn.attr[co.S2D][co.BYTES].get(co.CELL, 0)
            if co.BYTES in conn.attr[co.D2S]:
                nb_bytes_d2s = conn.attr[co.D2S][co.BYTES].get(co.WIFI, 0) + conn.attr[co.D2S][co.BYTES].get(co.CELL, 0)

            if duration < 1:
                data[condition]['<1s'] += nb_bytes_s2d + nb_bytes_d2s
                count[condition]['<1s'] += 1
            elif duration < 30:
                data[condition]['1-30s'] += nb_bytes_s2d + nb_bytes_d2s
                count[condition]['1-30s'] += 1
            elif duration < 60:
                data[condition]['30-60s'] += nb_bytes_s2d + nb_bytes_d2s
                count[condition]['30-60s'] += 1
            else:
                data[condition]['>=60s'] += nb_bytes_s2d + nb_bytes_d2s
                count[condition]['>=60s'] += 1
            tot_count[condition] += 1

    for cond, data_cond in data.iteritems():
        print(cond + " with " + str(tot_count[cond]) + "connections:", file=log_file)
        total = 0.0
        for dur_type, value in data_cond.iteritems():
            total += value
        for dur_type, value in data_cond.iteritems():
            print(dur_type + " (has " + str(count[cond][dur_type]) + " with " + str(count[cond][dur_type] * 100 / (tot_count[cond] + 0.00001)) + "%): " + str(value) + " bytes (" + str(value * 100 / (total+ 0.00001)) + "%)", file=log_file)


def box_plot_cellular_percentage(log_file=sys.stdout, limit_duration=0, limit_bytes=0):
    base_graph_name_bytes = "summary_fraction_cellular_" + start_time + '_' + stop_time
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)

    fog_base_graph_name_bytes = "fog_cellular_" + start_time + '_' + stop_time
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Firefoxspdy': 'g', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}

    data_bytes = {'both3': {}, 'both4': {}}
    data_frac = {'both3': {}, 'both4': {}}
    nb_zero = {'both3': {}, 'both4': {}}
    bytes_zero = {'both3': {}, 'both4': {}}
    tot_conn = {'both3': {}, 'both4': {}}
    tot_bytes = {'both3': {}, 'both4': {}}

    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in data_bytes:
        data_bytes[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in nb_zero:
        nb_zero[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in bytes_zero:
        bytes_zero[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in tot_conn:
        tot_conn[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in tot_bytes:
        tot_bytes[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            for conn_id, conn in data.iteritems():
                if app not in data_frac[condition][co.S2D]:
                    for direction in data_frac[condition].keys():
                        data_frac[condition][direction][app] = []
                        data_bytes[condition][direction][app] = []
                        nb_zero[condition][direction][app] = 0
                        bytes_zero[condition][direction][app] = 0
                        tot_conn[condition][direction][app] = 0
                        tot_bytes[condition][direction][app] = 0

                # Only interested on MPTCP connections
                if isinstance(conn, mptcp.MPTCPConnection):
                    if conn.attr[co.DURATION] < limit_duration:
                        continue
                    conn_bytes_s2d = {'cellular': 0, 'wifi': 0}
                    conn_bytes_d2s = {'cellular': 0, 'wifi': 0}
                    if co.BYTES in conn.attr[co.S2D]:
                        for interface in conn.attr[co.S2D][co.BYTES]:
                            conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                    if co.BYTES in conn.attr[co.D2S]:
                        for interface in conn.attr[co.D2S][co.BYTES]:
                            conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.S2D not in flow.attr or co.D2S not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                    if conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'] > limit_bytes:
                        frac_cell_s2d = (min(1.0, (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])))
                        if frac_cell_s2d == 0:
                            nb_zero[condition][co.S2D][app] += 1
                            bytes_zero[condition][co.S2D][app] += conn_bytes_s2d['wifi']
                        data_frac[condition][co.S2D][app].append(frac_cell_s2d)
                        data_bytes[condition][co.S2D][app].append(conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])
                        tot_conn[condition][co.S2D][app] += 1
                        tot_bytes[condition][co.S2D][app] += conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi']

                    if conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'] > limit_bytes:
                        frac_cell_d2s = min(1.0, ((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])))
                        if frac_cell_d2s == 0:
                            nb_zero[condition][co.D2S][app] += 1
                            bytes_zero[condition][co.D2S][app] += conn_bytes_d2s['wifi']
                        data_frac[condition][co.D2S][app].append(frac_cell_d2s)
                        data_bytes[condition][co.D2S][app].append(conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])
                        tot_conn[condition][co.D2S][app] += 1
                        tot_bytes[condition][co.D2S][app] += conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi']

    data_scatter = {co.S2D: {}, co.D2S: {}}
    for condition in data_bytes:
        for direction in data_bytes[condition]:
            nb_zeros = 0.
            bytes_zeros = 0.
            total_conn = 0.
            total_bytes = 0.
            data_scatter[direction][condition] = {}
            for app in data_bytes[condition][direction]:
                data_scatter[direction][condition][app] = zip(data_bytes[condition][direction][app], data_frac[condition][direction][app])
                print(condition, direction, app, "NB ZERO", nb_zero[condition][direction][app], "BYTES ZERO", bytes_zero[condition][direction][app])
                nb_zeros += nb_zero[condition][direction][app]
                bytes_zeros += bytes_zero[condition][direction][app]
                total_conn += tot_conn[condition][direction][app]
                total_bytes += tot_bytes[condition][direction][app]
            print("TOTAL:", nb_zeros, "zero conns over", total_conn, nb_zeros / total_conn * 100., "%", bytes_zeros, "zero bytes over", total_bytes, bytes_zeros / total_bytes * 100., "%")

    co.scatter_plot_with_direction(data_scatter, "Bytes on connection", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, y_to_one=True, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])


    for cond, data_cond in data_frac.iteritems():
        for direction, data_dir in data_cond.iteritems():
            plt.figure()
            fig, ax = plt.subplots()
            apps = data_dir.keys()
            to_plot = []
            print("Data", file=log_file)
            for app in apps:
                to_plot.append(data_frac[cond][direction][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes on cellular", fontsize=18)
                plt.ylim([0.0, 1.0])
                plt.savefig(base_graph_path_bytes + "_" + cond + "_" + direction + ".pdf")
            plt.close()


def cdf_bytes_all(log_file=sys.stdout):
    base_graph_name_bytes = "cdf_bytes_all_" + start_time + '_' + stop_time
    base_graph_path_bytes = os.path.join(sums_dir_exp, base_graph_name_bytes)
    tot_bytes = {'all': {'bytes': []}}

    data_frac = {'both3': {}, 'both4': {}}
    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname)
            for conn_id, conn in data.iteritems():
                if app not in data_frac[condition][co.S2D]:
                    for direction in data_frac[condition].keys():
                        data_frac[condition][direction][app] = []

                # Only interested on MPTCP connections
                elif isinstance(conn, mptcp.MPTCPConnection):
                    conn_bytes_s2d = {'cellular': 0, 'wifi': 0}
                    conn_bytes_d2s = {'cellular': 0, 'wifi': 0}
                    if co.BYTES in conn.attr[co.S2D]:
                        for interface in conn.attr[co.S2D][co.BYTES]:
                            conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                    if co.BYTES in conn.attr[co.D2S]:
                        for interface in conn.attr[co.D2S][co.BYTES]:
                            conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                    tot_bytes['all']['bytes'].append(conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])

    co.plot_cdfs_natural(tot_bytes, ['r'], "Bytes", base_graph_path_bytes)


def cdf_rtt_s2d_all(log_file=sys.stdout, min_samples=5, min_bytes=100):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    graph_fname = "rtt_avg_s2d_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D not in flow.attr or co.RTT_SAMPLES not in flow.attr[co.S2D]:
                        break
                    if flow.attr[co.S2D][co.RTT_SAMPLES] >= min_samples and flow.attr[co.S2D][co.BYTES] >= min_bytes:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.S2D][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.S2D not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.S2D]:
                    break
                if conn.flow.attr[co.S2D][co.RTT_SAMPLES] >= min_samples and conn.flow.attr[co.S2D][co.BYTES] >= min_bytes:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', graph_full_path)


def cdf_rtt_d2s_all(log_file=sys.stdout, min_samples=5):
    aggl_res = {}
    wifi = "wifi"
    cell = "cellular"
    graph_fname = "rtt_avg_d2s_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in aggl_res:
            aggl_res[condition] = {wifi: [], cell: []}

        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    if co.D2S not in flow.attr or co.RTT_SAMPLES not in flow.attr[co.D2S]:
                        break
                    if flow.attr[co.D2S][co.RTT_SAMPLES] >= min_samples:
                        aggl_res[condition][flow.attr[co.IF]] += [(flow.attr[co.D2S][co.RTT_AVG], fname)]
            elif isinstance(conn, tcp.TCPConnection):
                if co.D2S not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.D2S]:
                    break
                if conn.flow.attr[co.D2S][co.RTT_SAMPLES] >= min_samples:
                    aggl_res[condition][conn.flow.attr[co.IF]] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]

    co.log_outliers(aggl_res, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(aggl_res, ['red', 'blue', 'green', 'black'], 'RTT (ms)', graph_full_path)


def cdf_rtt_s2d_single_graph_all(log_file=sys.stdout, min_samples=5, min_bytes=100):
    wifi = "Wi-Fi"
    cell_3 = "3G"
    cell_4 = "4G"
    aggl_res = {wifi: [], cell_3: [], cell_4: []}
    graph_fname = "rtt_avg_s2d_all_tcp_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition.startswith('tcp') and 'both' not in condition:
            for conn_id, conn in data.iteritems():
                if isinstance(conn, tcp.TCPConnection):
                    if co.S2D not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.S2D]:
                        break
                    if conn.flow.attr[co.S2D][co.RTT_SAMPLES] >= min_samples and conn.flow.attr[co.S2D][co.BYTES] >= min_bytes:
                        if conn.flow.attr[co.S2D][co.RTT_AVG] >= 1.0:
                            if 'wlan' in fname:
                                aggl_res[wifi] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]
                            elif 'rmnet3' in fname:
                                aggl_res[cell_3] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]
                            elif 'rmnet4' in fname:
                                aggl_res[cell_4] += [(conn.flow.attr[co.S2D][co.RTT_AVG], fname)]

    results = {'all': aggl_res}

    co.log_outliers(results, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(results, ['red', 'blue', 'green', 'black'], 'RTT (ms)', graph_full_path)


def cdf_rtt_d2s_single_graph_all(log_file=sys.stdout, min_samples=5, min_bytes=100):
    wifi = "Wi-Fi"
    cell_3 = "3G"
    cell_4 = "4G"
    aggl_res = {wifi: [], cell_3: [], cell_4: []}
    graph_fname = "rtt_avg_d2s_all_tcp_" + args.app + "_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition.startswith('tcp') and 'both' not in condition:
            for conn_id, conn in data.iteritems():
                if isinstance(conn, tcp.TCPConnection):
                    if co.S2D not in conn.flow.attr or co.RTT_SAMPLES not in conn.flow.attr[co.D2S]:
                        break
                    if conn.flow.attr[co.D2S][co.RTT_SAMPLES] >= min_samples and conn.flow.attr[co.D2S][co.BYTES] >= min_bytes:
                        if conn.flow.attr[co.D2S][co.RTT_AVG] >= 1.0:
                            if 'wlan' in fname:
                                aggl_res[wifi] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]
                            elif 'rmnet3' in fname:
                                aggl_res[cell_3] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]
                            elif 'rmnet4' in fname:
                                aggl_res[cell_4] += [(conn.flow.attr[co.D2S][co.RTT_AVG], fname)]

    results = {'all': aggl_res}

    co.log_outliers(results, remove=args.remove, log_file=log_file)
    co.plot_cdfs_natural(results, ['red', 'blue', 'green', 'black'], 'RTT (ms)', graph_full_path)


def boxplot_bytes(log_file=sys.stdout):
    aggl_res = {co.S2D: {}, co.D2S: {}}
    label_names = ['Bytes s2d', 'Bytes d2s']
    color = ['b', 'g']
    ecolor = ['g', 'r']
    ylabel = 'Bytes'
    title = 'Number of bytes transfered of ' + args.app
    base_graph_fname = "boxplot_bytes_" + start_time + "_" + stop_time
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)

    # Need to agglomerate same tests
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        app = get_app_name(fname)
        s2d = 0
        d2s = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, mptcp.MPTCPConnection):
                if co.BYTES_MPTCPTRACE in conn.attr[co.S2D]:
                    s2d += conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
                if co.BYTES_MPTCPTRACE in conn.attr[co.D2S]:
                    d2s += conn.attr[co.D2S][co.BYTES_MPTCPTRACE]
            elif isinstance(conn, tcp.TCPConnection):
                if co.BYTES in conn.attr[co.S2D]:
                    s2d += conn.flow.attr[co.S2D][co.BYTES]
                if co.BYTES in conn.attr[co.D2S]:
                    d2s += conn.flow.attr[co.D2S][co.BYTES]

        if condition not in aggl_res[co.S2D]:
            for direction in aggl_res:
                aggl_res[direction][condition] = {}

        if app not in aggl_res[direction][condition]:
            for direction in aggl_res:
                aggl_res[direction][condition][app] = []

        if s2d < 0 or s2d >= 100000000:
            print("Please check " + fname)
        else:
            aggl_res[co.S2D][condition][app].append(s2d)
        if d2s < 0 or d2s >= 100000000:
            print("Please check " + fname)
        else:
            aggl_res[co.D2S][condition][app].append(d2s)

    for direction in aggl_res:
        for condition in aggl_res[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = aggl_res[direction][condition].keys()
            to_plot = []
            print("Data bytes boxplot", file=log_file)
            for app in apps:
                to_plot.append(aggl_res[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Bytes of all scenario", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def reinject_plot(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "reinject_bytes_" + start_time + "_" + stop_time
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {}, co.D2S: {}}
    results_packs = {co.S2D: {}, co.D2S: {}}
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            if condition not in results[co.S2D]:
                for direction in results:
                    results[direction][condition] = {}
                    results_packs[direction][condition] = {}

            if app not in results[direction][condition]:
                for direction in results:
                    results[direction][condition][app] = []
                    results_packs[direction][condition][app] = []
            for conn_id, conn in data.iteritems():
                reinject_bytes_s2d = 0.0
                reinject_bytes_d2s = 0.0
                reinject_packs_s2d = 0.0
                reinject_packs_d2s = 0.0
                bytes_s2d = 0.0
                bytes_d2s = 0.0
                packs_s2d = 0.0
                packs_d2s = 0.0

                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D in flow.attr and co.D2S in flow.attr:
                        if co.REINJ_ORIG_BYTES in flow.attr[co.S2D] and co.REINJ_ORIG_BYTES in flow.attr[co.D2S]:
                            if co.BYTES in flow.attr[co.S2D]:
                                bytes_s2d += flow.attr[co.S2D][co.BYTES]
                            else:
                                continue
                            if co.BYTES in flow.attr[co.D2S]:
                                bytes_d2s += flow.attr[co.D2S][co.BYTES]
                            else:
                                continue
                            reinject_bytes_s2d += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                            reinject_bytes_d2s += flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                            reinject_packs_s2d += flow.attr[co.S2D][co.REINJ_ORIG_PACKS]
                            reinject_packs_d2s += flow.attr[co.D2S][co.REINJ_ORIG_PACKS]
                            packs_s2d += flow.attr[co.S2D][co.PACKS]
                            packs_d2s += flow.attr[co.D2S][co.PACKS]

                if bytes_s2d > min_bytes:
                    results[co.S2D][condition][app].append(reinject_bytes_s2d / bytes_s2d)
                    results_packs[co.S2D][condition][app].append(reinject_packs_s2d / packs_s2d)

                if bytes_d2s > min_bytes:
                    if (reinject_bytes_d2s / bytes_d2s) >= 0.5:
                        print("reinj: " + str(reinject_bytes_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                    results[co.D2S][condition][app].append(reinject_bytes_d2s / bytes_d2s)
                    results_packs[co.D2S][condition][app].append(reinject_packs_d2s / packs_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            print("Reinject bytes boxplot", file=log_file)
            for app in apps:
                to_plot.append(results[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes reinjected", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()
            packs_base_graph_fname = "reinject_packs_" + start_time + "_" + stop_time
            packs_base_graph_full_path = os.path.join(sums_dir_exp, packs_base_graph_fname)
            plt.figure()
            fig, ax = plt.subplots()
            apps = results_packs[direction][condition].keys()
            to_plot = []
            print("Reinject packs boxplot", file=log_file)
            for app in apps:
                to_plot.append(results_packs[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of packs reinjected", fontsize=18)
                plt.savefig(packs_base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def retrans_plot(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "retrans_bytes_" + start_time + "_" + stop_time
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {}, co.D2S: {}}
    results_packs = {co.S2D: {}, co.D2S: {}}
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            if condition not in results[co.S2D]:
                for direction in results:
                    results[direction][condition] = {}
                    results_packs[direction][condition] = {}

            if app not in results[direction][condition]:
                for direction in results:
                    results[direction][condition][app] = []
                    results_packs[direction][condition][app] = []
            for conn_id, conn in data.iteritems():
                bytes_retrans_s2d = 0.0
                bytes_retrans_d2s = 0.0
                packs_retrans_s2d = 0.0
                packs_retrans_d2s = 0.0
                bytes_s2d = 0.0
                bytes_d2s = 0.0
                packs_s2d = 0.0
                packs_d2s = 0.0

                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D in flow.attr and co.D2S in flow.attr:
                        if co.BYTES_RETRANS in flow.attr[co.S2D] and co.BYTES_RETRANS in flow.attr[co.D2S]:
                            if co.BYTES in flow.attr[co.S2D]:
                                bytes_s2d += flow.attr[co.S2D][co.BYTES]
                            else:
                                continue
                            if co.BYTES in flow.attr[co.D2S]:
                                bytes_d2s += flow.attr[co.D2S][co.BYTES]
                            else:
                                continue
                            bytes_retrans_d2s += flow.attr[co.D2S][co.BYTES_RETRANS]
                            bytes_retrans_s2d += flow.attr[co.S2D][co.BYTES_RETRANS]
                            packs_retrans_s2d += flow.attr[co.S2D][co.PACKS_RETRANS]
                            packs_retrans_d2s += flow.attr[co.D2S][co.PACKS_RETRANS]
                            packs_s2d += flow.attr[co.S2D][co.PACKS]
                            packs_d2s += flow.attr[co.D2S][co.PACKS]

                if bytes_s2d > min_bytes:
                    results[co.S2D][condition][app].append(bytes_retrans_s2d / bytes_s2d)
                    results_packs[co.S2D][condition][app].append(bytes_retrans_s2d / packs_s2d)

                if bytes_d2s > min_bytes:
                    if (bytes_retrans_d2s / bytes_d2s) >= 0.5:
                        print("retrans: " + str(bytes_retrans_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                    results[co.D2S][condition][app].append(bytes_retrans_d2s / bytes_d2s)
                    results_packs[co.D2S][condition][app].append(bytes_retrans_d2s / packs_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            print("Retransmitted bytes boxplot", file=log_file)
            for app in apps:
                to_plot.append(results[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes retransmitted", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()
            packs_base_graph_fname = "retrans_packs_" + start_time + "_" + stop_time
            packs_base_graph_full_path = os.path.join(sums_dir_exp, packs_base_graph_fname)
            plt.figure()
            fig, ax = plt.subplots()
            apps = results_packs[direction][condition].keys()
            to_plot = []
            print("Reinject packs boxplot", file=log_file)
            for app in apps:
                to_plot.append(results_packs[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of packs retransmitted", fontsize=18)
                plt.savefig(packs_base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def reinject_plot_relative_to_data(log_file=sys.stdout, min_bytes=0.0):
    base_graph_fname = "reinject_data_bytes_" + start_time + "_" + stop_time
    base_graph_full_path = os.path.join(sums_dir_exp, base_graph_fname)
    results = {co.S2D: {}, co.D2S: {}}
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname)
            if condition not in results[co.S2D]:
                for direction in results:
                    results[direction][condition] = {}

            if app not in results[direction][condition]:
                for direction in results:
                    results[direction][condition][app] = []
            for conn_id, conn in data.iteritems():
                if not co.S2D in conn.attr or not co.D2S in conn.attr:
                    continue
                reinject_bytes_s2d = 0.0
                reinject_bytes_d2s = 0.0
                bytes_s2d = 0.0
                bytes_d2s = 0.0
                if co.BYTES_MPTCPTRACE in conn.attr[co.S2D]:
                    bytes_s2d = conn.attr[co.S2D][co.BYTES_MPTCPTRACE]
                if co.BYTES_MPTCPTRACE in conn.attr[co.D2S]:
                    bytes_d2s = conn.attr[co.D2S][co.BYTES_MPTCPTRACE]

                # reinject_bytes_s2d = 0
                # reinject_bytes_d2s = 0
                # reinject_packs_s2d = 0
                # reinject_packs_d2s = 0
                for flow_id, flow in conn.flows.iteritems():
                    if co.S2D in flow.attr and co.D2S in flow.attr:
                        if co.REINJ_ORIG_BYTES in flow.attr[co.S2D] and co.REINJ_ORIG_BYTES in flow.attr[co.D2S]:
                            reinject_bytes_s2d += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                            reinject_bytes_d2s += flow.attr[co.S2D][co.REINJ_ORIG_BYTES]

                if bytes_s2d > min_bytes:
                    results[co.S2D][condition][app].append(reinject_bytes_s2d / bytes_s2d)

                if bytes_d2s > min_bytes:
                    if (reinject_bytes_d2s / bytes_d2s) >= 0.5:
                        print("reinj: " + str(reinject_bytes_d2s) + " tot: " + str(bytes_d2s) + " " + fname + " " + conn_id)
                    results[co.D2S][condition][app].append(reinject_bytes_d2s / bytes_d2s)

    for direction in results:
        for condition in results[direction]:
            plt.figure()
            fig, ax = plt.subplots()
            apps = results[direction][condition].keys()
            to_plot = []
            print("Reinject bytes boxplot", file=log_file)
            for app in apps:
                to_plot.append(results[direction][condition][app])
            print(to_plot, file=log_file)
            if to_plot:
                plt.boxplot(to_plot)
                plt.xticks(range(1, len(apps) + 1), apps)
                plt.tick_params(axis='both', which='major', labelsize=10)
                plt.tick_params(axis='both', which='minor', labelsize=8)
                plt.ylabel("Fraction of bytes reinjected from all data bytes", fontsize=18)
                plt.savefig(base_graph_full_path + "_" + condition + "_" + direction + ".pdf")
            plt.close()


def box_plot_cellular_percentage_rtt_wifi(log_file=sys.stdout, limit_duration=0, limit_bytes=0):
    fog_base_graph_name_bytes = "fog_cellular_rtt_wifi_" + start_time + '_' + stop_time
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Firefoxspdy': 'g', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}

    data_rtt = {'both3': {}, 'both4': {}}
    data_frac = {'both3': {}, 'both4': {}}
    for cond in data_frac:
        data_frac[cond] = {co.S2D: {}, co.D2S: {}}

    for cond in data_rtt:
        data_rtt[cond] = {co.S2D: {}, co.D2S: {}}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            for conn_id, conn in data.iteritems():
                if app not in data_frac[condition][co.S2D]:
                    for direction in data_frac[condition]:
                        data_frac[condition][direction][app] = []
                        data_rtt[condition][direction][app] = []

                # Only interested on MPTCP connections
                if isinstance(conn, mptcp.MPTCPConnection):
                    if conn.attr[co.DURATION] < limit_duration:
                        continue
                    conn_bytes_s2d = {'cellular': 0, 'wifi': 0}
                    conn_bytes_d2s = {'cellular': 0, 'wifi': 0}
                    rtt_max_wifi_s2d = None
                    rtt_max_wifi_d2s = None
                    if co.BYTES in conn.attr[co.S2D]:
                        for interface in conn.attr[co.S2D][co.BYTES]:
                            conn_bytes_s2d[interface] += conn.attr[co.S2D][co.BYTES][interface]
                    if co.BYTES in conn.attr[co.D2S]:
                        for interface in conn.attr[co.D2S][co.BYTES]:
                            conn_bytes_d2s[interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.S2D not in flow.attr or co.D2S not in flow.attr:
                            continue
                        if co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        conn_bytes_s2d[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        conn_bytes_d2s[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]
                        if interface == co.WIFI:
                            rtt_max_wifi_s2d = flow.attr[co.S2D][co.RTT_MAX]
                            rtt_max_wifi_d2s = flow.attr[co.D2S][co.RTT_MAX]

                    if conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'] > limit_bytes:
                        if (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi']) > 0.6:
                            print("S2D: " + str((conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])) + " " + str(conn_bytes_s2d['cellular']) + " " + str(conn_bytes_s2d['wifi']) + " " + fname + " " + conn_id + " " + str(conn.attr[co.DURATION]) + " " + conn.flows['0'].attr[co.IF] + " " + str(conn.flows['0'].attr[co.S2D][co.RTT_STDEV]) + " " + conn.flows['1'].attr[co.IF] + " " + str(conn.flows['1'].attr[co.S2D][co.RTT_STDEV]))
                        frac_cell_s2d = (min(1.0, (conn_bytes_s2d['cellular'] + 0.0) / (conn_bytes_s2d['cellular'] + conn_bytes_s2d['wifi'])))
                        data_frac[condition][co.S2D][app].append(frac_cell_s2d)
                        data_rtt[condition][co.S2D][app].append(rtt_max_wifi_s2d)

                    if conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'] > limit_bytes:
                        if (conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi']) > 0.6:
                            print("D2S: " + str((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])) + " " + str(conn_bytes_d2s['cellular']) + " " + str(conn_bytes_d2s['wifi']) + " " + fname + " " + conn_id + " " + str(conn.attr[co.DURATION]) + " " + conn.flows['0'].attr[co.IF] + " " + str(conn.flows['0'].attr[co.D2S][co.RTT_STDEV]) + " " + conn.flows['1'].attr[co.IF] + " " + str(conn.flows['1'].attr[co.D2S][co.RTT_STDEV]))
                        frac_cell_d2s = min(1.0, ((conn_bytes_d2s['cellular'] + 0.0) / (conn_bytes_d2s['cellular'] + conn_bytes_d2s['wifi'])))
                        data_frac[condition][co.D2S][app].append(frac_cell_d2s)
                        data_rtt[condition][co.D2S][app].append(rtt_max_wifi_d2s)

    count = 1
    data_scatter = {co.S2D: {}, co.D2S: {}}
    for condition in data_rtt:
        for direction in data_rtt[condition]:
            data_scatter[direction][condition] = {}
            for app in data_rtt[condition][direction]:
                data_scatter[direction][condition][app] = zip(data_rtt[condition][direction][app], data_frac[condition][direction][app])

    co.scatter_plot_with_direction(data_scatter, "Max RTT on Wi-Fi (ms)", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, log_scale_x=False)


def check_ok(value):
    if value < 0 or value >= 100000000:
        return 0
    return value


def textual_summary_global(log_file=sys.stdout):
    conn_number = {}
    tests_number = {}
    bytes_number = {}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in conn_number:
            conn_number[condition] = 0
            tests_number[condition] = 0
            bytes_number[condition] = {co.S2D: {co.CELL: 0, co.WIFI: 0}, co.D2S: {co.CELL: 0, co.WIFI: 0}}

        conn_number[condition] += len(data)
        tests_number[condition] += 1
        for conn_id, conn in data.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                ith = conn.flow.attr[co.IF]
                print(ith, fname, conn_id)
                if ith not in bytes_number[condition][co.S2D]:
                    continue
                for direction in co.DIRECTIONS:
                    bytes_number[condition][direction][ith] += check_ok(conn.flow.attr[direction][co.BYTES])

            elif isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    ith = flow.attr[co.IF]
                    for direction in co.DIRECTIONS:
                        reinjected = 0
                        if direction in flow.attr:
                            if co.REINJ_ORIG in flow.attr[direction]:
                                for start_seq, stop_seq in flow.attr[direction][co.REINJ_ORIG]:
                                    reinjected += stop_seq - start_seq
                            if co.BYTES in flow.attr[direction]:
                                bytes_number[condition][direction][ith] += check_ok(flow.attr[direction][co.BYTES] - reinjected)

    total = 0
    total_tests = 0
    total_s2d = 0
    total_d2s = 0
    for cond, cond_num in conn_number.iteritems():
        print(cond + ": ", cond_num, " connections with ", tests_number[cond], " tests;", file=log_file)
        total += cond_num
        total_tests += tests_number[cond]
        for direction in co.DIRECTIONS:
            ratio = (bytes_number[cond][direction][co.CELL] + 0.0) / (bytes_number[cond][direction][co.WIFI] + bytes_number[cond][direction][co.CELL]) * 100 if bytes_number[cond][direction][co.WIFI] + bytes_number[cond][direction][co.CELL] > 0 else 0
            print(direction, bytes_number[cond][direction][co.CELL], " bytes cell and ", bytes_number[cond][direction][co.WIFI], "bytes wifi (", ratio, "% cell)", file=log_file)
        for ith in [co.WIFI, co.CELL]:
            total_s2d += bytes_number[cond][co.S2D][ith]
            total_d2s += bytes_number[cond][co.D2S][ith]

    total_ratio = (total_s2d + 0.0) / (total_s2d + total_d2s) * 100 if total_s2d + total_d2s > 0 else 0
    print("Total: " + str(total) + " connections with " + str(total_tests) + " tests; " + str(total_s2d) + " bytes S2D and " + str(total_d2s) + " D2S (" + str(total_ratio) + " % s2d)", file=log_file)


def textual_summary_app(log_file=sys.stdout):
    results = {}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        app = get_app_name(fname).title()
        if condition not in results:
            results[condition] = {}
        if app not in results[condition]:
            results[condition][app] = {'conn': [], 'bytes_s2d': {}, 'bytes_d2s': {}}

        results[condition][app]['conn'].append(len(data))

        bytes_s2d = 0
        bytes_d2s = 0
        for conn_id, conn in data.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                bytes_s2d += conn.flow.attr[co.S2D][co.BYTES]
                bytes_d2s += conn.flow.attr[co.D2S][co.BYTES]

        results[condition][app]['bytes_s2d'].append(bytes_s2d)
        results[condition][app]['bytes_d2s'].append(bytes_d2s)


    for condition in results:
        print(condition, file=log_file)
        print("Application & \# connections & Bytes smartphone to server & Bytes server to smartphone", file=log_file)
        for app in results[condition]:
            print(app, "&", np.mean(results[condition][app]['conn']), "&", np.mean(results[condition][app]['bytes_s2d']), "&", np.mean(results[condition][app]['bytes_d2s']), r"\\", file=log_file)
            print("\hline", file=log_file)


def cdf_overhead_retrans_reinj(log_file=sys.stdout):
    results = {co.S2D: {}, co.D2S: {}}
    results_two = {co.S2D: {}, co.D2S: {}}
    graph_fname = "overhead_retrans_reinj_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'mptcp_fm' in condition and 'both' in condition:
            if condition not in results[co.S2D]:
                for direction in co.DIRECTIONS:
                    results[direction][condition] = {'Reinjection': [], 'Retransmission': []}
                    results_two[direction][condition] = []

            for conn_id, conn in data.iteritems():
                retrans_bytes = {co.S2D: 0, co.D2S: 0}
                reinj_bytes = {co.S2D: 0, co.D2S: 0}
                total_bytes = {co.S2D: 0, co.D2S: 0}
                total_data_bytes = {co.S2D: 0, co.D2S: 0}
                reinj_data_bytes = {co.S2D: 0, co.D2S: 0}


                for flow_id, flow in conn.flows.iteritems():
                    for direction in co.DIRECTIONS:
                        if co.BYTES in flow.attr[direction]:
                            # total_bytes[direction] += flow.attr[direction][co.BYTES_FRAMES_TOTAL]
                            total_bytes[direction] = total_bytes[direction] + flow.attr[direction][co.BYTES]
                            # retrans_bytes[direction] += flow.attr[direction].get(co.BYTES_FRAMES_RETRANS, 0)
                            retrans_bytes[direction] = retrans_bytes[direction] + flow.attr[direction].get(co.BYTES_RETRANS, 0)
                            # reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0) + (flow.attr[direction].get(co.REINJ_ORIG_PACKS, 0) * co.FRAME_MPTCP_OVERHEAD)
                            reinj_bytes[direction] = reinj_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)
                            total_data_bytes[direction] = total_data_bytes[direction] + flow.attr[direction].get(co.BYTES, 0)
                            reinj_data_bytes[direction] = reinj_data_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

                for direction in co.DIRECTIONS:
                    if total_bytes[direction] > 0:
                        results[direction][condition]['Retransmission'].append((reinj_bytes[direction] + 0.0) / total_bytes[direction])
                        results[direction][condition]['Reinjection'].append((retrans_bytes[direction] + 0.0) / total_bytes[direction])
                        results_two[direction][condition].append([total_data_bytes[direction], reinj_data_bytes[direction]])

    co.plot_cdfs_with_direction(results, ['red', 'blue'], 'Fraction of total bytes', graph_full_path, natural=True)
    for direction in results_two:
        for condition in results_two[direction]:
            sorted_data = sorted(results_two[direction][condition], key=lambda elem: elem[0])
            to_plot = [[], []]
            i = 0
            for point in sorted_data:
                to_plot[0].append([i, point[0]])
                to_plot[1].append([i, point[1]])
                i += 1
            tot_graph_full_path = graph_full_path + "_details_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(to_plot, ['Total', 'Reinjections'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)

def fog_rtt_bytes(log_file=sys.stdout):
    results = {co.S2D: {}, co.D2S: {}}
    color = {'3G': 'blue', '4G': 'red', 'WiFi': 'green'}
    base_graph_name = "fog_rtt_bytes_" + start_time + '_' + stop_time

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)
        if condition not in results[co.S2D]:
            for direction in co.DIRECTIONS:
                results[direction][condition] = {'3G': [], '4G': [], 'WiFi': []}

        for conn_id, conn in conns.iteritems():

            if isinstance(conn, tcp.TCPConnection):
                for direction in co.DIRECTIONS:
                    if direction not in conn.flow.attr:
                        continue
                    if co.RTT_AVG not in conn.flow.attr[direction]:
                        continue
                    if conn.flow.attr[co.IF] == co.WIFI:
                        ith = 'WiFi'
                    elif conn.flow.attr[co.IF] == co.CELL and ('both3' in condition or 'rmnet3' in condition):
                        ith = '3G'
                    elif conn.flow.attr[co.IF] == co.CELL and ('both4' in condition or 'rmnet4' in condition):
                        ith = '4G'
                    results[direction][condition][ith].append([conn.flow.attr[direction][co.RTT_AVG], conn.flow.attr[direction][co.BYTES]])

            elif isinstance(conn, mptcp.MPTCPConnection):
                for flow_id, flow in conn.flows.iteritems():
                    for direction in co.DIRECTIONS:
                        if direction not in flow.attr:
                            continue
                        if co.RTT_AVG not in flow.attr[direction]:
                            continue
                        if flow.attr[co.IF] == co.WIFI:
                            ith = 'WiFi'
                        elif flow.attr[co.IF] == co.CELL and ('both3' in condition or 'rmnet3' in condition):
                            ith = '3G'
                        elif flow.attr[co.IF] == co.CELL and ('both4' in condition or 'rmnet4' in condition):
                            ith = '4G'
                        if direction in flow.attr:
                            results[direction][condition][ith].append([flow.attr[direction][co.RTT_AVG], flow.attr[direction].get(co.BYTES, 0)])

    co.scatter_plot_with_direction(results, "Mean RTT [ms]", "Bytes on connection", color, sums_dir_exp, base_graph_name, plot_identity=False, log_scale_x=False)


def cdf_duration_mptcp_tcp(log_file=sys.stdout, limit_bytes=10000):
    results = {co.S2D: {'MPTCP Both4': [], 'TCP 4G': [], 'TCP WiFi': []}, co.D2S: {'MPTCP Both4': [], 'TCP 4G': [], 'TCP WiFi': []}}
    color = {'MPTCP Both4': 'blue', 'TCP 4G': 'red', 'TCP WiFi': 'green'}
    base_graph_name = "cdf_duration_mptcp_tcp_" + start_time + '_' + stop_time
    graph_full_path = os.path.join(sums_dir_exp, base_graph_name)

    for fname, conns in connections.iteritems():
        condition = get_experiment_condition(fname)

        for conn_id, conn in conns.iteritems():
            if isinstance(conn, tcp.TCPConnection):
                if 'rmnet4' in condition:
                    for direction in co.DIRECTIONS:
                        if conn.flow.attr[direction][co.BYTES] >= limit_bytes:
                            results[direction]['TCP 4G'].append(conn.flow.attr[co.DURATION])
                elif 'wlan' in condition:
                    for direction in co.DIRECTIONS:
                        if conn.flow.attr[direction][co.BYTES] >= limit_bytes:
                            results[direction]['TCP WiFi'].append(conn.flow.attr[co.DURATION])

            elif isinstance(conn, mptcp.MPTCPConnection):
                if 'both4' in condition:
                    for direction in co.DIRECTIONS:
                        if conn.attr[direction][co.BYTES_MPTCPTRACE] >= limit_bytes:
                            results[direction]['MPTCP Both4'].append(conn.attr[co.DURATION])

    co.plot_cdfs_natural(results, ['red', 'blue', 'green', 'black'], 'Duration (s)', graph_full_path)


def plot_total_bytes_reinj_bytes(log_file=sys.stdout):
    results = {co.S2D: {}, co.D2S: {}}
    results_raw = {co.S2D: {}, co.D2S: {}}
    graph_fname = "total_bytes_reinj_bytes_" + start_time + "_" + stop_time
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)

        if 'mptcp_fm' in condition and 'both' in condition:
            if condition not in results:
                for direction in co.DIRECTIONS:
                    results[direction][condition] = [[], []]
                    results_raw[direction][condition] = []

                for conn_id, conn in data.iteritems():
                    if isinstance(conn, mptcp.MPTCPConnection):
                        reinj_bytes = {co.S2D: 0, co.D2S: 0}
                        total_bytes = {co.S2D: 0, co.D2S: 0}

                        for flow_id, flow in conn.flows.iteritems():
                            for direction in co.DIRECTIONS:
                                if co.BYTES in flow.attr[direction]:
                                    total_bytes[direction] += flow.attr[direction][co.BYTES]
                                    reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

                        for direction in co.DIRECTIONS:
                            results_raw[direction][condition].append([total_bytes[direction], reinj_bytes[direction]])

    for direction in results_raw:
        for condition in results_raw[direction]:
            results_raw[direction][condition] = sorted(results_raw[direction][condition], key=lambda elem: elem[0])
            i = 0
            for point in results_raw[direction][condition]:
                results[direction][condition][0].append([i, point[0]])
                results[direction][condition][1].append([i, point[1]])
                i += 1

            tot_graph_full_path = graph_full_path + "_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(results[direction][condition], ['Total', 'Reinjections'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def cdf_overhead_retrans_reinj_new(log_file=sys.stdout):
    results = {co.S2D: {}, co.D2S: {}}
    graph_fname = "overhead_retrans_reinj_" + start_time + "_" + stop_time + '.pdf'
    graph_full_path = os.path.join(sums_dir_exp, graph_fname)
    retrans_bytes = {co.S2D: 0, co.D2S: 0}
    reinj_bytes = {co.S2D: 0, co.D2S: 0}
    total_bytes = {co.S2D: 0, co.D2S: 0}
    total_data_bytes = {co.S2D: 0, co.D2S: 0}
    reinj_data_bytes = {co.S2D: 0, co.D2S: 0}
    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'mptcp_fm' in condition and 'both' in condition:
            if condition not in results[co.S2D]:
                for direction in co.DIRECTIONS:
                    results[direction][condition] = []

            for conn_id, conn in data.iteritems():
                for direction in co.DIRECTIONS:
                    retrans_bytes[direction] = 0
                    reinj_bytes[direction] = 0
                    total_bytes[direction] = 0
                    total_data_bytes[direction] = 0
                    reinj_data_bytes[direction] = 0

                for flow_id, flow in conn.flows.iteritems():
                    for direction in co.DIRECTIONS:
                        if direction not in flow.attr:
                            continue
                        if co.BYTES in flow.attr[direction]:
                            # total_bytes[direction] += flow.attr[direction][co.BYTES_FRAMES_TOTAL]
                            total_bytes[direction] = total_bytes[direction] + flow.attr[direction][co.BYTES]
                            # retrans_bytes[direction] += flow.attr[direction].get(co.BYTES_FRAMES_RETRANS, 0)
                            retrans_bytes[direction] = retrans_bytes[direction] + flow.attr[direction].get(co.BYTES_RETRANS, 0)
                            # reinj_bytes[direction] += flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0) + (flow.attr[direction].get(co.REINJ_ORIG_PACKS, 0) * co.FRAME_MPTCP_OVERHEAD)
                            reinj_bytes[direction] = reinj_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)
                            total_data_bytes[direction] = total_data_bytes[direction] + flow.attr[direction].get(co.BYTES, 0)
                            reinj_data_bytes[direction] = reinj_data_bytes[direction] + flow.attr[direction].get(co.REINJ_ORIG_BYTES, 0)

                for direction in co.DIRECTIONS:
                    results[direction][condition].append((total_data_bytes[direction], reinj_data_bytes[direction]))

    for direction in results:
        for condition in results[direction]:
            sorted_data = sorted(results[direction][condition], key=lambda elem: elem[0])
            to_plot = [[], []]
            i = 0
            for point in sorted_data:
                to_plot[0].append([i, point[0]])
                to_plot[1].append([i, point[1]])
                i += 1
            tot_graph_full_path = graph_full_path + "_details_" + direction + "_" + condition + ".pdf"
            co.plot_line_graph(to_plot, ['Total', 'Reinjections'], ['b', 'r'], 'Connections', 'Number of data bytes', '', tot_graph_full_path, y_log=True)


def fog_plot_cellular_percentage_all(log_file=sys.stdout, limit_duration=0, limit_bytes=0):

    fog_base_graph_name_bytes = "fog_cellular_all_" + start_time + '_' + stop_time
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Firefoxspdy': 'g', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}

    data_frac = {'both3': {}, 'both4': {}}
    data_bytes = {'both3': {}, 'both4': {}}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            for conn_id, conn in data.iteritems():
                if app not in data_frac[condition]:
                    data_frac[condition][app] = []
                    data_bytes[condition][app] = []

                # Only interested on MPTCP connections
                if isinstance(conn, mptcp.MPTCPConnection):
                    if conn.attr[co.DURATION] < limit_duration:
                        continue
                    conn_bytes = {'cellular': 0, 'wifi': 0}
                    if co.BYTES in conn.attr[co.S2D]:
                        for interface in conn.attr[co.S2D][co.BYTES]:
                            conn_bytes[interface] += conn.attr[co.S2D][co.BYTES][interface]
                    if co.BYTES in conn.attr[co.D2S]:
                        for interface in conn.attr[co.D2S][co.BYTES]:
                            conn_bytes[interface] += conn.attr[co.D2S][co.BYTES][interface]
                    for flow_id, flow in conn.flows.iteritems():
                        if co.S2D not in flow.attr or co.D2S not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.S2D] or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                            break
                        interface = flow.attr[co.IF]
                        conn_bytes[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]
                        conn_bytes[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]

                    if conn_bytes['cellular'] + conn_bytes['wifi'] > limit_bytes:
                        frac_cell = (min(1.0, (conn_bytes['cellular'] + 0.0) / (conn_bytes['cellular'] + conn_bytes['wifi'])))
                        data_frac[condition][app].append(frac_cell)
                        data_bytes[condition][app].append(conn_bytes['cellular'] + conn_bytes['wifi'])

    data_scatter = {}
    for condition in data_bytes:
        data_scatter[condition] = {}
        for app in data_bytes[condition]:
            data_scatter[condition][app] = zip(data_bytes[condition][app], data_frac[condition][app])

    co.scatter_plot(data_scatter, "Bytes on connection", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, y_to_one=True, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])


def fog_plot_cellular_percentage_scenario(log_file=sys.stdout, limit_duration=0, limit_bytes=0):

    fog_base_graph_name_bytes = "fog_cellular_scenario_" + start_time + '_' + stop_time
    fog_base_graph_path_bytes = os.path.join(sums_dir_exp, fog_base_graph_name_bytes)

    color = {'Dailymotion': 'brown', 'Drive': 'm', 'Dropbox': 'g', 'Facebook': 'c', 'Firefox': 'orange', 'Firefoxspdy': 'g', 'Messenger': 'b', 'Spotify': 'k', 'Youtube': 'r'}
    UPLOAD_APPS = ['Drive', 'Dropbox', 'Facebook', 'Messenger']
    DOWNLOAD_APPS = ['Dailymotion', 'Firefox', 'Spotify', 'Youtube']

    data_frac = {'both3': {}, 'both4': {}}
    data_bytes = {'both3': {}, 'both4': {}}

    for fname, data in connections.iteritems():
        condition = get_experiment_condition(fname)
        if 'both' in condition and 'mptcp_fm_' in condition:
            condition = condition[9:]
            app = get_app_name(fname).title()
            for conn_id, conn in data.iteritems():
                if app not in data_frac[condition]:
                    data_frac[condition][app] = []
                    data_bytes[condition][app] = []

                # Only interested on MPTCP connections
                if isinstance(conn, mptcp.MPTCPConnection):
                    if conn.attr[co.DURATION] < limit_duration:
                        continue
                    conn_bytes = {'cellular': 0, 'wifi': 0}
                    if app in UPLOAD_APPS:
                        if co.BYTES in conn.attr[co.S2D]:
                            for interface in conn.attr[co.S2D][co.BYTES]:
                                conn_bytes[interface] += conn.attr[co.S2D][co.BYTES][interface]
                        for flow_id, flow in conn.flows.iteritems():
                            if co.S2D not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.S2D]:
                                break
                            interface = flow.attr[co.IF]
                            conn_bytes[interface] -= flow.attr[co.S2D][co.REINJ_ORIG_BYTES]

                    elif app in DOWNLOAD_APPS:
                        if co.BYTES in conn.attr[co.D2S]:
                            for interface in conn.attr[co.D2S][co.BYTES]:
                                conn_bytes[interface] += conn.attr[co.D2S][co.BYTES][interface]
                        for flow_id, flow in conn.flows.iteritems():
                            if co.D2S not in flow.attr or co.REINJ_ORIG_BYTES not in flow.attr[co.D2S]:
                                break
                            interface = flow.attr[co.IF]
                            conn_bytes[interface] -= flow.attr[co.D2S][co.REINJ_ORIG_BYTES]


                    if conn_bytes['cellular'] + conn_bytes['wifi'] > limit_bytes:
                        frac_cell = (min(1.0, (conn_bytes['cellular'] + 0.0) / (conn_bytes['cellular'] + conn_bytes['wifi'])))
                        data_frac[condition][app].append(frac_cell)
                        data_bytes[condition][app].append(conn_bytes['cellular'] + conn_bytes['wifi'])

    data_scatter = {}
    for condition in data_bytes:
        data_scatter[condition] = {}
        for app in data_bytes[condition]:
            data_scatter[condition][app] = zip(data_bytes[condition][app], data_frac[condition][app])

    co.scatter_plot(data_scatter, "Bytes on connection", "Fraction of bytes on cellular", color, sums_dir_exp, fog_base_graph_path_bytes, plot_identity=False, log_scale_y=False, y_to_one=True, label_order=['Dailymotion', 'Drive', 'Dropbox', 'Facebook', 'Firefox', 'Messenger', 'Spotify', 'Youtube'])


millis = int(round(time.time() * 1000))

log_file = open(os.path.join(sums_dir_exp, 'log_summary_' + args.app + '_' + args.cond + '_' + split_agg[0] + '_' + split_agg[1] + '-' + str(millis) + '.txt'), 'w')
if args.app:
    print("Remove option is " + str(args.remove), file=log_file)
    print("Plot count", file=log_file)
    bar_chart_count_connections(log_file=log_file)
    print("Plot bytes", file=log_file)
    bar_chart_bytes(log_file=log_file)
    print("Plot duration", file=log_file)
    bar_chart_duration(log_file=log_file)
    print("Plot bytes s2d", file=log_file)
    bar_chart_bytes_s2d_interface(log_file=log_file)
    print("Plot bytes d2s", file=log_file)
    bar_chart_bytes_d2s_interface(log_file=log_file)
    print("Plot duration all", file=log_file)
    bar_chart_duration_all(log_file=log_file)
    print("Plot packs retrans", file=log_file)
    bar_chart_packs_retrans(log_file=log_file)
    print("Plot packs retrans s2d", file=log_file)
    bar_chart_packs_retrans_s2d_interface(log_file=log_file)
    print("Plot packs retrans d2s", file=log_file)
    bar_chart_packs_retrans_d2s_interface(log_file=log_file)
    # print("Plot line graph aggl", file=log_file)
    # line_graph_aggl()
    print("Plot rtt average s2d", file=log_file)
    bar_chart_rtt_average_s2d_interface(log_file=log_file)
    print("Plot rtt average d2s", file=log_file)
    bar_chart_rtt_average_d2s_interface(log_file=log_file)
    print("Plot rtt stdev s2d", file=log_file)
    bar_chart_rtt_stdev_s2d_interface(log_file=log_file)
    print("Plot rtt stdev d2s", file=log_file)
    bar_chart_rtt_stdev_d2s_interface(log_file=log_file)
    print("Plot boxplot duration", file=log_file)
    time_completion_big_connections(log_file=log_file)
elif args.cond:
    print("To be implemented after", file=log_file)
else:
    print("Summary plots", file=log_file)
    percentage_cell_by_app_with_conditions(log_file=log_file)
    percentage_cell_by_condition_with_apps(log_file=log_file)
    nb_conns_by_app(log_file=log_file)
    fog_plot_with_bytes_wifi_cell_per_condition(log_file=log_file)
    fog_plot_with_packs_wifi_cell_per_condition(log_file=log_file)
    fog_duration_bytes(log_file=log_file)
    cdfs_summary(log_file=log_file)
    textual_summary(log_file=log_file)
    box_plot_cellular_percentage(log_file=log_file, limit_bytes=0)
    cdf_bytes_all(log_file=log_file)
    cdf_rtt_s2d_all(log_file=log_file, min_samples=5)
    boxplot_bytes(log_file=log_file)
    reinject_plot(log_file=log_file, min_bytes=9999.9)
    reinject_plot_relative_to_data(log_file=log_file, min_bytes=9999.9)
    cdf_rtt_s2d_single_graph_all(log_file=log_file)
    retrans_plot(log_file=log_file)
    box_plot_cellular_percentage_rtt_wifi(log_file=log_file)
    textual_summary_global(log_file=log_file)
    cdf_overhead_retrans_reinj(log_file=log_file)
    fog_rtt_bytes(log_file=log_file)
    cdf_duration_mptcp_tcp(log_file=log_file)
    plot_total_bytes_reinj_bytes(log_file=log_file)
    cdf_overhead_retrans_reinj_new(log_file=log_file)
    fog_plot_cellular_percentage_all(log_file=log_file)
log_file.close()
print("End of summary")
